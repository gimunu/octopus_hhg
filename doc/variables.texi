@node Input Variables,,,
@chapter Input Variables

@code{octopus} has quite a few options, that we will subdivide in different groups.
After the name of the option, its type and default value (when applicable)
are given in parenthesis.
@node Calculation Modes,,,
@section Calculation Modes
@c ----------------------------------

@itemize
@item @strong{CalculationMode}@*
@vindex @code{CalculationMode}@*
@emph{Section}: Calculation Modes@*
@emph{Type}: integer@*
@emph{Default}: gs@*
@* Decides what kind of calculation is to be performed.


@emph{Options}:
@itemize @minus
@item @strong{gs}:  Calculation of the ground state.
@item @strong{unocc}:  Calculation of unoccupied/virtual KS states.
@item @strong{td}:  Time-dependent calculation (experimental for periodic systems).
@item @strong{go}:  Optimization of the geometry.
@item @strong{opt_control}:  Optimal control.
@item @strong{em_resp}:  Calculation of the electromagnetic response: electric
 polarizabilities and hyperpolarizabilities and magnetic
 susceptibilities (experimental for periodic systems).
@item @strong{casida}:  Excitations via Casida linear-response TDDFT; for finite systems only.
@item @strong{td_transport}:  Time-dependent quantum transport (experimental).
@item @strong{vdw}:  Calculate van der Waals coefficients.
@item @strong{vib_modes}:  Calculation of the vibrational modes.
@item @strong{one_shot}:  Use the self-consistent wavefunctions in the @t{restart} directory to
 evaluate the total energy using a different XC functional.
 This is effectively a first-order perturbative calculation of the total energy,
 the perturbation being the difference between the two XC potentials used.
@item @strong{kdotp}:  Calculation of effective masses by @emph{k.p} perturbation theory (experimental).
@item @strong{gcm}:  Generator-Coordinates Method calculation (experimental).
 Ref. K. Capelle, @emph{J. Chem. Phys.} @strong{119}, 1285 (2003).
@item @strong{dummy}:  This calculation mode does nothing. Useful for debugging, testing and benchmarking.
@item @strong{invert_ks}:  Invert the Kohn-Sham equations (experimental).
@item @strong{recipe}:  Prints out a tasty recipe.

 May also be used as a block for multi-dataset mode. The first line is a list of calculation modes,
 the second is labels (optional), and the third is the order for the runs (optional). Example:

 <pre>%CalculationMode
   gs     | unocc  | td
   "run1" | "run2" | "run3"
   1      | 2      | 3
 %</pre>
@end itemize

@c ----------------------------------
@end itemize
@node Generator Coordinates,,,
@subsection Generator Coordinates
@c ----------------------------------

@itemize
@item @strong{GCMSlaterDeterminants}@*
@vindex @code{GCMSlaterDeterminants}@*
@emph{Section}: Calculation Modes::Generator Coordinates@*
@emph{Type}: block@*
@* Specify which Slater determinants are to be used, each generated from a previous
 ground-state calculation. Supply a list of names of the directories in which the
 results of each calculation was saved.



@c ----------------------------------
@end itemize
@node Geometry Optimization,,,
@subsection Geometry Optimization
@c ----------------------------------

@itemize
@item @strong{GOCenter}@*
@vindex @code{GOCenter}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* (Experimental) If set to yes, Octopus centers the geometry at
 every optimization step. It also reduces the degrees of
 freedom of the optimization by using the translational
 invariance. The default is no.



@c ----------------------------------
@item @strong{GOMaxIter}@*
@vindex @code{GOMaxIter}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: integer@*
@emph{Default}: 200@*
@* Even if the convergence criterion is not satisfied, the minimization will stop
 after this number of iterations.



@c ----------------------------------
@item @strong{GOMethod}@*
@vindex @code{GOMethod}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: integer@*
@emph{Default}: steep@*
@* Method by which the minimization is performed.


@emph{Options}:
@itemize @minus
@item @strong{steep}:  Simple steepest descent.
@item @strong{cg_fr}:  Fletcher-Reeves conjugate-gradient algorithm. The
 conjugate-gradient algorithm proceeds as a succession of line
 minimizations. The sequence of search directions is used to build
 up an approximation to the curvature of the function in the
 neighborhood of the minimum.
@item @strong{cg_pr}:  Polak-Ribiere conjugate-gradient algorithm.
@item @strong{cg_bfgs}:  Vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) conjugate-gradient algorithm.
 It is a quasi-Newton method which builds up an approximation to the second
 derivatives of the function @emph{f} using the difference between successive gradient
 vectors.  By combining the first and second derivatives, the algorithm is able
 to take Newton-type steps towards the function minimum, assuming quadratic
 behavior in that region.
@item @strong{cg_bfgs2}:  The bfgs2 version of this minimizer is the most efficient version available,
 and is a faithful implementation of the line minimization scheme described in
 Fletcher, @emph{Practical Methods of Optimization}, Algorithms 2.6.2 and 2.6.4.
@item @strong{simplex}:  This is experimental, and in fact, @strong{not} recommended unless you just want to
 fool around. It is the Nead-Melder simplex algorithm, as implemented in the
 GNU Scientific Library (GSL). It does not make use of the gradients (@emph{i.e.}, the
 forces) which makes it less efficient than other schemes. It is included here
 for completeness, since it is free.
@end itemize

@c ----------------------------------
@item @strong{GOMinimumMove}@*
@vindex @code{GOMinimumMove}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: float@*
@emph{Default}: 0.0 a.u.@*
@* Convergence criterion, for stopping the minimization. In
 units of length; minimization is stopped when the coordinates
 of all species change less than @t{GOMinimumMove}.  Used
 in conjunction with @t{GOTolerance}. If
 @t{GOMinimumMove = 0}, this criterion is ignored. The
 default is 0.001 [b].

 Note that if you use @t{GOMethod =
 simplex}, then you must supply a non-zero
 @t{GOMinimumMove}.



@c ----------------------------------
@item @strong{GOObjective}@*
@vindex @code{GOObjective}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: integer@*
@emph{Default}: minimize_energy@*
@* This rather esoteric option allows one to choose which objective function
 to minimize during a geometry minimization. The use of this variable may
 lead to inconsistencies, so please make sure you know what you are doing!


@emph{Options}:
@itemize @minus
@item @strong{minimize_energy}:  Use the total energy as objective function.
@item @strong{minimize_forces}:  Use @math{\sqrt{\sum |f_i|^2}} as objective function.
 Note that in this case one still uses the forces as the gradient of the objective function.
 This is, of course, inconsistent, and may lead to very strange behavior.
@end itemize

@c ----------------------------------
@item @strong{GOStep}@*
@vindex @code{GOStep}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: float@*
@emph{Default}: 0.5@*
@* Initial step for the geometry optimizer.
 WARNING: in some weird units.



@c ----------------------------------
@item @strong{GOTolerance}@*
@vindex @code{GOTolerance}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: float@*
@emph{Default}: 0.001 a.u.@*
@* Convergence criterion, for stopping the minimization. In
 units of force; minimization is stopped when all forces on
 ions are smaller than this criterion.  Used in conjunction
 with @t{GOMinimumMove}. If @t{GOTolerance = 0},
 this criterion is ignored. The default is 0.001 H/b (0.05
 eV/Angstrom).



@c ----------------------------------
@end itemize
@node Invert KS,,,
@subsection Invert KS
@c ----------------------------------

@itemize
@item @strong{InvertKSConvAbsDens}@*
@vindex @code{InvertKSConvAbsDens}@*
@emph{Section}: Calculation Modes::Invert KS@*
@emph{Type}: float@*
@emph{Default}: 1e-5@*
@* Absolute difference between the calculated and the target density in the KS
 inversion. Has to be larger than the convergence of the density in the SCF run.



@c ----------------------------------
@item @strong{InvertKSStabilizer}@*
@vindex @code{InvertKSStabilizer}@*
@emph{Section}: Calculation Modes::Invert KS@*
@emph{Type}: float@*
@emph{Default}: 0.5@*
@* Additive constant @emph{c} in the iterative calculation of the KS potential
   (v(alpha+1)=rho(alpha)+c)/(rho_target+c)*v(alpha)
 ensures that very small densities do not cause numerical problems.



@c ----------------------------------
@item @strong{InvertKSTargetDensity}@*
@vindex @code{InvertKSTargetDensity}@*
@emph{Section}: Calculation Modes::Invert KS@*
@emph{Type}: string@*
@emph{Default}: @t{target_density.dat}@*
@* Name of the file that contains the density used as the target in the
 inversion of the KS equations.



@c ----------------------------------
@item @strong{InvertKSVerbosity}@*
@vindex @code{InvertKSVerbosity}@*
@emph{Section}: Calculation Modes::Invert KS@*
@emph{Type}: integer@*
@* Selects what is output during the calculation of the KS potential.


@emph{Options}:
@itemize @minus
@item @strong{0}:  Only outputs the converged density and KS potential.
@item @strong{1}:  Same as 0 but outputs the maximum difference to the target density in each
 iteration in addition.
@item @strong{2}:  Same as 1 but outputs the density and the KS potential in each iteration in
 addition.
@end itemize

@c ----------------------------------
@item @strong{InvertKSmethod}@*
@vindex @code{InvertKSmethod}@*
@emph{Section}: Calculation Modes::Invert KS@*
@emph{Type}: integer@*
@emph{Default}: iterative@*
@* Selects whether the exact two-particle method or the iterative scheme
 is used to invert the density to get the KS potential.


@emph{Options}:
@itemize @minus
@item @strong{iterative}:  Iterative scheme for v_s.
@item @strong{two_particle}:  Exact two-particle scheme.
@item @strong{iterativevxc}:  Iterative scheme for v_xc.
@end itemize

@c ----------------------------------
@end itemize
@node Optimal Control,,,
@subsection Optimal Control
@c ----------------------------------

@itemize
@item @strong{OCTCheckGradient}@*
@vindex @code{OCTCheckGradient}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* When doing QOCT with the conjugate-gradient optimization scheme, the gradient is
 computed thanks to a forward-backwards propagation. For debugging purposes, this
 gradient can be compared with the value obtained "numerically" (@emph{i.e.} by doing
 successive forward propagations with control fields separated by small finite
 differences).

 In order to activate this feature, set @t{OCTCheckGradient} to some non-zero value,
 which will be the finite difference used to numerically compute the gradient.



@c ----------------------------------
@item @strong{OCTControlFunctionOmegaMax}@*
@vindex @code{OCTControlFunctionOmegaMax}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: float@*
@emph{Default}: -1.0@*
@* The Fourier series that can be used to represent the control functions must be truncated;
 the truncation is given by a cut-off frequency which is determined by this variable.



@c ----------------------------------
@item @strong{OCTControlFunctionRepresentation}@*
@vindex @code{OCTControlFunctionRepresentation}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@emph{Default}: control_fourier_series_h@*
@* If @t{OCTControlRepresentation = control_function_parametrized}, one must
 specify the kind of parameters that determine the control function.
 If @t{OCTControlRepresentation = control_function_real_time}, then this variable
 is ignored, and the control function is handled directly in real time.


@emph{Options}:
@itemize @minus
@item @strong{control_fourier_series_h}:  The control function is expanded as a full Fourier series (although it must, of
 course, be a real function). Then, the total fluence is fixed, and a transformation
 to hyperspherical coordinates is done; the parameters to optimize are the hyperspherical
 angles.
@item @strong{control_zero_fourier_series_h}:  The control function is expanded as a Fourier series, but assuming (1) that the zero
 frequency component is zero, and (2) the control function, integrated in time, adds
 up to zero (this essentially means that the sum of all the cosine coefficients is zero).
 Then, the total fluence is fixed, and a transformation to hyperspherical coordinates is
 done; the parameters to optimize are the hyperspherical angles.
@item @strong{control_fourier_series}:  The control function is expanded as a full Fourier series (although it must, of
 course, be a real function). The control parameters are the coefficients of this
 basis-set expansion.
@item @strong{control_zero_fourier_series}:  The control function is expanded as a full Fourier series (although it must, of
 course, be a real function). The control parameters are the coefficients of this
 basis-set expansion. The difference with the option @t{control_fourier_series} is that
 (1) that the zero-frequency component is zero, and (2) the control function, integrated
 in time, adds up to zero (this essentially means that the sum of all the cosine
 coefficients is zero).
@end itemize

@c ----------------------------------
@item @strong{OCTControlFunctionType}@*
@vindex @code{OCTControlFunctionType}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@emph{Default}: controlfunction_mode_epsilon@*
@* The control function may fully determine the time-dependent form of the
 external field, or only the envelope function of this external field, or its phase.
 Or, we may have two different control functions, one of them providing the phase
 and the other one, the envelope.

 Note that, if @t{OCTControlRepresentation = control_function_real_time}, then the control
 function must @strong{always} determine the full external field.


@emph{Options}:
@itemize @minus
@item @strong{controlfunction_mode_epsilon}:  In this case, the control function determines the full control function: namely,
 if we are considering the electric field of a laser, the time-dependent electric field.
@item @strong{controlfunction_mode_f}:  The optimization process attempts to find the best possible envelope. The full
 control field is this envelope times a cosine function with a "carrier" frequency.
 This carrier frequency is given by the carrier frequency of the @t{TDExternalFields}
 in the @t{inp} file.
@item @strong{controlfunction_mode_phi}:  The optimization process attempts to find the best possible time-dependent phase. That is,
 the external field would be given by a function in the form e(t) = f(t)*cos(w0*t+phi(t)),
 where f(t) is an "envelope", w0 a carrier frequency, and phi(t) the td phase that we
 wish to optimize.
@end itemize

@c ----------------------------------
@item @strong{OCTControlRepresentation}@*
@vindex @code{OCTControlRepresentation}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@emph{Default}: control_function_real_time@*
@* Optimal Control Theory can be performed with @t{Octopus} in two different modes:
 either considering the control function to be described in full in real time,
 or to be represented by a set of parameters (which may, or may not be,
 the coefficients of its expansion in a given basis). The particular choice
 for these parameters is specified by variable @t{OCTParameterRepresentation}
 (this variable will be ignored if the control function is to be represented
 directly in real time).


@emph{Options}:
@itemize @minus
@item @strong{control_function_real_time}:  The control functions are represented directly in real time.
@item @strong{control_function_parametrized}:  The control functions are specified by a set of parameters.
@end itemize

@c ----------------------------------
@item @strong{OCTCurrentFunctional}@*
@vindex @code{OCTCurrentFunctional}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@emph{Default}: oct_no_curr@*
@* The variable @t{OCTCurrentFunctional} describes which kind of current target functional J1_c[j] is
 to be used. EXPERIMENTAL!


@emph{Options}:
@itemize @minus
@item @strong{oct_no_curr}:  No current functional is used, no current calculated.
@item @strong{oct_curr_square}:  Calculates the square of current j: J1_c[j] = @t{OCTCurrentWeight}*\int|j(r)|^2 dr.
 For @t{OCTCurrentWeight} .LT. 0 the current will be minimized (useful in combination with
 target density in order to obtain stable final target density), while for
 OCTCurrentWeight} .GT. 0 it will be maximized (useful in combination with a target density
 in order to obtain a high-velocity impact, for instance). It is a static target, to be reached at
 total time.
@item @strong{oct_max_curr_ring}:  Maximizes the current of a quantum ring in one direction. The functional maximizes the z projection of the
 outer product between the position \vec{r} and the current \vec{j}:
 J1[j] = @t{OCTCurrentWeight}*\int (\vec{r} \times \vec{j}) \hat{z} dr. For @t{OCTCurrentWeight} .GT. 0. the
 current flows in counter clockwise direction, while for @t{OCTCurrentWeight} .LT. 0 the current is clockwise.
@item @strong{oct_curr_square_td}:  The time dependent version of @t{oct_curr_square}. In fact, calculates the
 square of current in time interval [@t{OCTStartTimeCurrTg},
 total time = @t{TDMaximumIter} * @t{TDTimeStep}].
 Set @t{TDPropagator } = @t{crank_nicholson}
@end itemize

@c ----------------------------------
@item @strong{OCTCurrentWeight}@*
@vindex @code{OCTCurrentWeight}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* In the case of simultaneous optimization of density n and current j, one can tune the importance
 of the current functional J1_c[j], as the respective functionals might not provide results on the
 same scale of magnitude. J1[n,j]= J1_d[n]+ @t{OCTCurrentWeight} * J1_c[j]. Be aware that its
 sign is crucial for the chosen @t{OCTCurrentFunctional} as explained there.



@c ----------------------------------
@item @strong{OCTDirectStep}@*
@vindex @code{OCTDirectStep}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: float@*
@emph{Default}: 0.25@*
@* If you choose @t{OCTScheme = oct_algorithm_direct} or @t{OCTScheme = oct_algorithm_newuoa},
 the algorithms necessitate an initial "step" to perform the direct search for the
 optimal value. The precise meaning of this "step" differs.



@c ----------------------------------
@item @strong{OCTDoubleCheck}@*
@vindex @code{OCTDoubleCheck}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* In order to make sure that the optimized field indeed does its job, the code
 may run a normal propagation after the optimization using the optimized field.



@c ----------------------------------
@item @strong{OCTDumpIntermediate}@*
@vindex @code{OCTDumpIntermediate}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* Writes to disk the laser pulse data during the OCT algorithm at intermediate steps.
 These are files called @t{opt_control/laser.xxxx}, where @t{xxxx} is the iteration number.



@c ----------------------------------
@item @strong{OCTEps}@*
@vindex @code{OCTEps}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: float@*
@emph{Default}: 1.0e-6@*
@* Define the convergence threshold. It computes the difference between the "input"
 field in the iterative procedure, and the "output" field. If this difference is
 less than @t{OCTEps} the iteration is stopped. This difference is defined as:

 @math{
 D[\epsilon^{i},\epsilon^{o}] = \int_0^T dt \vert \epsilon^{i}(t)-\epsilon^{o}(t)\vert^2\,.
 }

 (If there are several control fields, this difference is defined as the sum over
 all the individual differences.)

 Whenever this condition is satisfied, it means that we have reached a solution point
 of the QOCT equations, @emph{i.e.} a critical point of the QOCT functional (not
 necessarily a maximum, and not necessarily the global maximum).



@c ----------------------------------
@item @strong{OCTExcludedStates}@*
@vindex @code{OCTExcludedStates}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: string@*
@* If the target is the exclusion of several targets, ("OCTTargetOperator = oct_exclude_states")
 then you must declare which states are to be excluded, by setting the OCTExcludedStates variable.
 It must be a string in "list" format: "1-8", or "2,3,4-9", for example. Be careful to include
 in this list only states that have been calculated in a previous "gs" or "unocc" calculation,
 or otherwise the error will be silently ignored.



@c ----------------------------------
@item @strong{OCTFilter}@*
@vindex @code{OCTFilter}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* The block @t{OCTFilter} describes the type and shape of the filter function
 that are applied to the optimized laser field in each iteration.
 The filter forces the laser field to obtain the given form in frequency space.
 Each line of the block describes a filter; this way you can actually have more
 than one filter function (@emph{e.g.} a filter in time and two in frequency space).
 The filters are applied in the given order, @emph{i.e.}, first the filter specified
 by the first line is applied, then second line.
 The syntax of each line is, then:

 @t{%OCTFilter
 @*@ @ domain | function
 @*%}


 Possible arguments for domain are:

 (i) @t{frequency_filter}: Specifies a spectral filter.

 (ii) @t{time_filter}: DISABLED IN THIS VERSION.

 Example:

 @t{%OCTFilter
 @*@ @ time | "exp(-80*( w + 0.1567 )^2  ) + exp(-80*( w - 0.1567 )^2  )"
 @*%}

 Be careful that also the negative-frequency component is filtered since the resulting
 field has to be real-valued.



@emph{Options}:
@itemize @minus
@item @strong{frequency_filter}:  The filter is applied in the frequency domain.
@end itemize

@c ----------------------------------
@item @strong{OCTFixFluenceTo}@*
@vindex @code{OCTFixFluenceTo}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* The algorithm tries to obtain the specified fluence for the laser field.
 This works only in conjunction with either the WG05 or the straight iteration scheme.

 If this variable is not present in the input file, by default the code will not
 attempt a fixed-fluence QOCT run. The same holds if the value given to this
 variable is exactly zero.

 If this variable is given a negative value, then the target fluence will be that of
 the initial laser pulse given as guess in the input file. Note, however, that
 first the code applies the envelope provided by the @t{OCTLaserEnvelope} input
 option, and afterwards it calculates the fluence.



@c ----------------------------------
@item @strong{OCTFixInitialFluence}@*
@vindex @code{OCTFixInitialFluence}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* By default, when asking for a fixed-fluence optimization (@t{OCTFixFluenceTo = whatever}),
 the initial laser guess provided in the input file is scaled to match this
 fluence. However, you can force the program to use that initial laser as the initial
 guess, no matter the fluence, by setting @t{OCTFixInitialFluence = no}.



@c ----------------------------------
@item @strong{OCTInitialState}@*
@vindex @code{OCTInitialState}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Describes the initial state of the quantum system.
 Possible arguments are:


@emph{Options}:
@itemize @minus
@item @strong{oct_is_groundstate}:  Start in the ground state.
@item @strong{oct_is_excited}:  Currently not in use.
@item @strong{oct_is_gstransformation}:  Start in a transformation of the ground-state orbitals, as defined in the
 block @t{OCTInitialTransformStates}.
@item @strong{oct_is_userdefined}:  Start in a userdefined state.
@end itemize

@c ----------------------------------
@item @strong{OCTInitialTransformStates}@*
@vindex @code{OCTInitialTransformStates}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* If @t{OCTInitialState = oct_is_gstransformation}, you must specify an
 @t{OCTInitialTransformStates} block, in order to specify which linear
 combination of the states present in @t{restart/gs} is used to
 create the initial state.

 The syntax is the same as the @t{TransformStates} block.



@c ----------------------------------
@item @strong{OCTInitialUserdefined}@*
@vindex @code{OCTInitialUserdefined}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* Define an initial state. Syntax follows the one of the @t{UserDefinedStates} block.
 Example:

 @t{%OCTInitialUserdefined
 @*@ @  1 | 1 | 1 |  "exp(-r^2)*exp(-i*0.2*x)"
 @*%}




@c ----------------------------------
@item @strong{OCTLaserEnvelope}@*
@vindex @code{OCTLaserEnvelope}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* Often a pre-defined time-dependent envelope on the control function is desired.
 This can be achieved by making the penalty factor time-dependent.
 Here, you may specify the required time-dependent envelope.

 It is possible to choose different envelopes for different control functions.
 There should be one line for each control function. Each line should
 have only one element: a string with the function that defines the
 @strong{inverse} of the time-dependent penalty, which is then defined as
 1 divided by (this function + 1.0e-7) (to avoid possible singularities).

 The usual choices should be functions between zero and one.

 If, instead of defining a function, the string is @t{default}, then
 the program will use the function:

 @math{ \frac{1}{\alpha(t)} = \frac{1}{2}( erf((100/T)*(t-T/20))+ erf(-(100/T)*(t-T+T/20)) }



@c ----------------------------------
@item @strong{OCTLocalTarget}@*
@vindex @code{OCTLocalTarget}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: string@*
@* If @t{OCTTargetOperator = oct_tg_local}, then one must supply a function
 that defines the target. This should be done by defining it through a string, using
 the variable @t{OCTLocalTarget}.



@c ----------------------------------
@item @strong{OCTMaxIter}@*
@vindex @code{OCTMaxIter}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@emph{Default}: 10@*
@* The maximum number of iterations.
 Typical values range from 10-100.



@c ----------------------------------
@item @strong{OCTMixing}@*
@vindex @code{OCTMixing}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Use mixing algorithms to create the input fields in the iterative OCT schemes.
 Note that this idea is still a little bit experimental, and depending on the
 kind of mixing that you use, and the parameters that you set, it may or may
 not accelerate the convergence, or even spoil the convergence.

 Using @t{TypeOfMixing = broyden}, @t{Mixing = 0.1} and @t{MixNumberSteps = 3} seems
 to work in many cases, but your mileage may vary.

 Note that mixing does not make sense (and is therefore not done, this variable
 being ignored), for some OCT algorithms (in particular, if @t{OCTScheme} is
 @t{oct_algorithm_direct} or @t{oct_algorithm_newuoa}).



@c ----------------------------------
@item @strong{OCTMoveIons}@*
@vindex @code{OCTMoveIons}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: logical@*
@* If @t{OCTTargetOperator = oct_tg_velocity}, then one must specify
 if the ions are assumed to be fixed or if they can move by setting
 @t{OCTMoveIons} to @t{true} or @t{false}.



@c ----------------------------------
@item @strong{OCTNumberCheckPoints}@*
@vindex @code{OCTNumberCheckPoints}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@* During an OCT propagation, the code may write the wavefunctions at some time steps (the
 "check points"). When the inverse backward or forward propagation
 is performed in a following step, the wavefunction should reverse its path
 (almost) exactly. This can be checked to make sure that it is the case -- otherwise
 one should try reducing the time-step, or altering in some other way the
 variables that control the propagation.

 If the backward (or forward) propagation is not retracing the steps of the previous
 forward (or backward) propagation, the code will write a warning.



@c ----------------------------------
@item @strong{OCTOptimizeHarmonicSpectrum}@*
@vindex @code{OCTOptimizeHarmonicSpectrum}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@emph{Default}: no@*
@* WARNING: Experimental

 If @t{OCTTargetOperator = oct_tg_hhg}, the target is the harmonic emission spectrum.
 In that case, you must supply an @t{OCTOptimizeHarmonicSpectrum} block in the @t{inp}
 file. The target is given, in general, by:

 @math{J_1 = \int_0^\infty d\omega \alpha(\omega) H(\omega)},

 where @math{H(\omega)} is the harmonic spectrum generated by the system, and
 @math{\alpha(\omega)} is some function that determines what exactly we want
 to optimize. The role of the @t{OCTOptimizeHarmonicSpectrum} block is to determine
 this @math{\alpha(\omega)} function. Currently, this function is defined as:

 @math{\alpha(\omega) = \sum_{L=1}^{M} \frac{\alpha_L}{a_L} \sqcap( (\omega - L\omega_0)/a_L )},

 where @math{omega_0} is the carrier frequency. @math{M} is
 the number of columns in the @t{OCTOptimizeHarmonicSpectrum} block. The values of @emph{L} will be listed
 in the first row of this block; @math{ alpha_L } in the second row, and @math{a_L} in
 the third.

 Example:

 @t{%OCTOptimizeHarmonicSpectrum
 @*@ @   7    |  9    | 11
 @*@ @  -1    |  1    | -1
 @*@ @   0.01 |  0.01 |  0.01
 @*%}




@c ----------------------------------
@item @strong{OCTPenalty}@*
@vindex @code{OCTPenalty}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* The variable specifies the value of the penalty factor for the
 integrated field strength (fluence). Large value = small fluence.
 A transient shape can be specified using the block @t{OCTLaserEnvelope}.
 In this case @t{OCTPenalty} is multiplied with time-dependent function.
 The value depends on the coupling between the states. A good start might be a
 value from 0.1 (strong fields) to 10 (weak fields).

 Note that if there are several control functions, one can specify this
 variable as a one-line code, each column being the penalty factor for each
 of the control functions. Make sure that the number of columns is equal to the
 number of control functions. If it is not a block, all control functions will
 have the same penalty factor.

 All penalty factors must be positive.



@c ----------------------------------
@item @strong{OCTRandomInitialGuess}@*
@vindex @code{OCTRandomInitialGuess}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* The initial field to start the optimization search is usually given in the @t{inp} file,
 through a @t{TDExternalFields} block. However, you can start from a random guess if you
 set this variable to true.

 Note, however, that this is only valid for the "direct" optimization schemes; moreover
 you still need to provide a @t{TDExternalFields} block.



@c ----------------------------------
@item @strong{OCTScheme}@*
@vindex @code{OCTScheme}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@emph{Default}: oct_algorithm_zbr98@*
@* Optimal Control Theory can be performed with @t{Octopus} with a variety of different
 algorithms. Not all of them can be used with any choice of target or control function
 representation. For example, some algorithms cannot be used if
 @t{OCTControlRepresentation = control_function_real_time}
 (@t{OCTScheme} .gt. @t{oct_algorithm_straight_iteration}), and others cannot be used
 if @t{OCTControlRepresentation = control_function_parametrized}
 (@t{OCTScheme} .lt. @t{oct_algorithm_straight_iteration}).


@emph{Options}:
@itemize @minus
@item @strong{oct_algorithm_zbr98}:  Backward-Forward-Backward scheme described in @emph{JCP} @strong{108}, 1953 (1998).
 Only possible if target operator is a projection operator.
 Provides fast, stable and monotonic convergence.
@item @strong{oct_algorithm_zr98}:  Forward-Backward-Forward scheme described in @emph{JCP} @strong{109}, 385 (1998).
 Works for projection and more general target operators also. The convergence is
 stable but slower than ZBR98.
 Note that local operators show an extremely slow convergence. It ensures monotonic
 convergence.
@item @strong{oct_algorithm_wg05}:  Forward-Backward scheme described in @emph{J. Opt. B.} @strong{7}, 300 (2005).
 Works for all kinds of target operators, can be used with all kinds of filters, and
 allows a fixed fluence.
 The price is a rather unstable convergence.
 If the restrictions set by the filter and fluence are reasonable, a good overlap can be
 expected within 20 iterations.
 No monotonic convergence.
@item @strong{oct_algorithm_mt03}:  Basically an improved and generalized scheme.
 Comparable to ZBR98/ZR98. See [Y. Maday and G. Turinici, @emph{J. Chem. Phys.} @strong{118}, 8191 (2003)].
@item @strong{oct_algorithm_krotov}:  The procedure reported in [D. Tannor, V. Kazakov and V.
 Orlov, in @emph{Time-Dependent Quantum Molecular Dynamics}, edited by J. Broeckhove
 and L. Lathouweres (Plenum, New York, 1992), pp. 347-360].
@item @strong{oct_algorithm_straight_iteration}:  Straight iteration: one forward and one backward propagation is performed at each
 iteration, both with the same control field. An output field is calculated with the
 resulting wavefunctions. Note that this scheme typically does not converge, unless
 some mixing (@t{OCTMixing = yes}) is used.
@item @strong{oct_algorithm_cg}:  Conjugate-gradients, as implemented in the GNU GSL library.
@item @strong{oct_algorithm_direct}:  This is a "direct" optimization scheme. This means that we do not make use of the
 "usual" QOCT equations (backward-forward propagations, etc), but we use some gradient-free
 maximization algorithm for the function that we want to optimize. In this case, the
 maximization algorithm is the Nelder-Mead algorithm as implemeted in the GSL. The function
 values are obtained by successive forward propagations.
@item @strong{oct_algorithm_newuoa}:  This is exactly the same as @t{oct_algorithm_direct}, except in this case the maximization
 algorithm is the so-called NEWUOA algorithm [M. J. D. Powell, @emph{IMA J. Numer. Analysis}
 @strong{28}, 649-664 (2008)].
@end itemize

@c ----------------------------------
@item @strong{OCTSpatialCurrWeight}@*
@vindex @code{OCTSpatialCurrWeight}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* Can be seen as a position dependent @t{OCTCurrentWeight}. Consequently, it
 weights contribution of current j to its functional J1_c[j] according to the position in space.
 For example, @t{oct_curr_square} thus becomes
 J1_c[j] = @t{OCTCurrentWeight} \int |j(r)|^2 @t{OCTSpatialCurrWeight}(r) dr.

 It is defined @t{OCTSpatialCurrWeight}(r) = g(x)*g(y)*g(z), where
 g(x) = \sum_{i} 1/(1+exp( -fact*(x-startpoint_i) )) - 1/(1+exp( -fact*(x-endpoint_i) )).
 If not specified, g(x) = 1.

 Each g(x) is represented by one line of the block that has the following form

 @t{%OCTSpatialCurrWeight
 @*@ @   dimension  |  fact |  startpoint_1  | endpoint_1  | startpoint_2 | endpoint_2 |...
 @*%}

 There are no restrictions on the number of lines, nor on the number of pairs of start- and endpoints.
 Attention: @t{startpoint} and @t{endpoint} have to be supplied pairwise
 with @t{startpoint .lt. endpoint}. @t{dimension .gt. 0} is integer, @t{fact} is float.



@c ----------------------------------
@item @strong{OCTStartIterCurrTg}@*
@vindex @code{OCTStartIterCurrTg}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@* Allows for a time dependent target for the current without defining it for the total
 time-interval of the simulation.
 Thus it can be switched on at the iteration desired, @t{OCTStartIterCurrTg} .ge. 0
 and  @t{OCTStartIterCurrTg} .lt. @t{TDMaximumIter}.
 Tip: If you would like to specify a real time for switching
 the functional on rather than the number of steps, just use something
 like:
 @t{OCTStartIterCurrTg} = 100.0 / @t{TDTimeStep}



@c ----------------------------------
@item @strong{OCTTargetDensity}@*
@vindex @code{OCTTargetDensity}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: string@*
@* If @t{OCTTargetOperator = oct_tg_density}, then one must supply the target density
 that should be searched for. This one can do by supplying a string through
 the variable @t{OCTTargetDensity}.



@c ----------------------------------
@item @strong{OCTTargetDensityFromState}@*
@vindex @code{OCTTargetDensityFromState}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@emph{Default}: no@*
@* If @t{OCTTargetOperator = oct_tg_density}, and @t{OCTLocalTarget = "OCTTargetDensityFromState"},
 you must specify a @t{OCTTargetDensityState} block, in order to specify which linear
 combination of the states present in @t{restart/gs} is used to
 create the target density.

 The syntax is the same as the @t{TransformStates} block.



@c ----------------------------------
@item @strong{OCTTargetOperator}@*
@vindex @code{OCTTargetOperator}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@emph{Default}: oct_tg_gstransformation@*
@* The variable @t{OCTTargetOperator} prescribes which kind of target functional is
 to be used.


@emph{Options}:
@itemize @minus
@item @strong{oct_tg_velocity}:  The target is a function of the velocities of the nuclei at the end of the influence of
 the external field, defined by @t{OCTVelocityTarget}
@item @strong{oct_tg_current}:  The target is exclusively a target in terms of the current.
 If combined with target that involves the density, set variable @t{OCTTargetOperator}= @t{OCTTargetDensity}
 and set explicitly @t{OCTCurrentFunctional}. Only this combination is enabled. All other targets force
 @t{OCTCurrentFunctional}=0.
@item @strong{oct_tg_groundstate}:  The target operator is a projection operator on the ground state, @emph{i.e.} the
 objective is to populate the ground state as much as possible.
@item @strong{oct_tg_excited}:  The target operator is an "excited state". This means that the target operator
 is a linear combination of Slater determinants, each one formed by replacing
 in the ground-state Slater determinant one occupied state with one excited
 state (@emph{i.e.} "single excitations"). The description of which excitations are
 used, and with which weights, should be given in a file called
 @t{oct-excited-state-target}. This is still in very preliminary, experimental
 phase. See the documentation of subroutine @t{excited_states_init} in the source
 code in order to use this feature.
@item @strong{oct_tg_gstransformation}:  The target operator is a projection operator on a transformation of the ground-state
 orbitals defined by the block @t{OCTTargetTransformStates}.
@item @strong{oct_tg_userdefined}:  Allows to define target state by using @t{OCTTargetUserdefined}.
@item @strong{oct_tg_density}:  The target operator is a given density, @emph{i.e.} the final state should have a density
 as close as possible as the one given in the input file, either from the variable
 @t{OCTTargetDensityFromState}, or from @t{OCTTargetDensity}. It can be extended to a
 combination with a current functional by setting @t{OCTCurrentFunctional} and attributing
 a value to @t{OCTCurrentWeight}.
@item @strong{oct_tg_local}:  The target operator is a local operator.
@item @strong{oct_tg_td_local}:  The target operator is a time-dependent local operator.
@item @strong{oct_tg_exclude_state}:  Target operator is the projection onto the complement of a given state, given by the
 block @t{OCTTargetTransformStates}. This means that the target operator is the unity
 operator minus the projector onto that state.
@item @strong{oct_tg_hhg}:  The target is the optimization of the HHG yield.
@end itemize

@c ----------------------------------
@item @strong{OCTTargetTransformStates}@*
@vindex @code{OCTTargetTransformStates}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@emph{Default}: no@*
@* If @t{OCTTargetOperator = oct_tg_gstransformation}, you must specify a
 @t{OCTTargetTransformStates} block, in order to specify which linear
 combination of the states present in @t{restart/gs} is used to
 create the target state.

 The syntax is the same as the @t{TransformStates} block.



@c ----------------------------------
@item @strong{OCTTargetUserdefined}@*
@vindex @code{OCTTargetUserdefined}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* Define a target state. Syntax follows the one of the @t{UserDefinedStates} block.
 Example:

 @t{%OCTTargetUserdefined
 @*@ @  1 | 1 | 1 |  "exp(-r^2)*exp(-i*0.2*x)"
 @*%}




@c ----------------------------------
@item @strong{OCTVelocityDerivatives}@*
@vindex @code{OCTVelocityDerivatives}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* If @t{OCTTargetOperator = oct_tg_velocity}, and
 @t{OCTScheme = oct_algorithm_cg} then you must supply
 the target in terms of the ionic velocities AND the derivatives
 of the target with respect to the ionic velocity components.
 The derivatives are supplied via strings trough the block
 @t{OCTVelocityDerivatives}.
 Each velocity component is supplied by @t{"v[n_atom,vec_comp]"},
 while "n_atom" is the atom number, corresponding to the
 @t{Coordinates} block and "vec_comp" is the corresponding
 vector component of the velocity. The first line of the
 @t{OCTVelocityDerivatives} block contains the derivatives
 with respect to "v[1,*]", the second with respect to "v[2,*]" and so
 on. The first column contains all derivatives with respect "v[*,1]",
 the second with respect to "v[*,2]" and the third w.r.t. "v[*,3]".
 As an example, we show the @t{OCTVelocityDerivatives} block
 corresponding to the target shown in the @t{OCTVelocityTarget}
 help section:

 @t{%OCTVelocityDerivatives}
 @t{ " 2*(v[1,1]-v[2,1])" | " 2*(v[1,2]-v[2,2])" | " 2*(v[1,3]-v[2,3])" }
 @t{ "-2*(v[1,1]-v[2,1])" | "-2*(v[1,2]-v[2,2])" | "-2*(v[1,3]-v[2,3])" }
 @t{%}




@c ----------------------------------
@item @strong{OCTVelocityTarget}@*
@vindex @code{OCTVelocityTarget}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* If @t{OCTTargetOperator = oct_tg_velocity}, then one must supply the
 target to optimize in terms of the ionic velocities. This is done by
 supplying a string trough the block @t{OCTVelocityTarget}.
 Each velocity component is supplied by @t{"v[n_atom,vec_comp]"},
 while "n_atom" is the respective atom number, corresponding to the
 @t{Coordinates} block and "vec_comp" is the corresponding
 vector component of the velocity. The target string can be
 supplied by using several lines in the OCTTargetOperator block.
 As an example, the following target can be used to maximize the
 velocity difference between atom 1 and 2 (in a 3D system):

 @t{%OCTVelocityTarget}
 @t{ "(v[1,1]-v[2,1])^2 + (v[1,2]-v[2,2])^2 + "}
 @t{ "(v[1,3]-v[2,3])^2"}
 @t{%}




@c ----------------------------------
@end itemize
@node Unoccupied States,,,
@subsection Unoccupied States
@c ----------------------------------

@itemize
@item @strong{NumberUnoccStates}@*
@vindex @code{NumberUnoccStates}@*
@emph{Section}: Calculation Modes::Unoccupied States@*
@emph{Type}: integer@*
@emph{Default}: 5@*
@* How many unoccupied states to compute.



@c ----------------------------------
@item @strong{UnoccMaximumIter}@*
@vindex @code{UnoccMaximumIter}@*
@emph{Section}: Calculation Modes::Unoccupied States@*
@emph{Type}: integer@*
@emph{Default}: 50@*
@* Maximum number of eigensolver iterations. The code will stop even if convergence
 has not been achieved. -1 means unlimited.



@c ----------------------------------
@end itemize
@node Execution,,,
@section Execution
@c ----------------------------------

@itemize
@item @strong{FromScratch}@*
@vindex @code{FromScratch}@*
@emph{Section}: Execution@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* When this variable is set to true, @t{Octopus} will perform a
 calculation from the beginning, without looking for restart
 information.



@c ----------------------------------
@end itemize
@node Debug,,,
@subsection Debug
@c ----------------------------------

@itemize
@item @strong{DebugLevel}@*
@vindex @code{DebugLevel}@*
@emph{Section}: Execution::Debug@*
@emph{Type}: integer@*
@* This variable decides whether or not to enter debug mode.
 If it is greater than 0, different amounts of additional information
 are written to standard output and additional assertion checks are performed.


@emph{Options}:
@itemize @minus
@item @strong{0}:  (default) @t{Octopus} does not enter debug mode.
@item @strong{1}:  Moderate amount of debug output; assertion checks enabled.
@item @strong{2}:  The code prints a stack trace as it enters end exits subroutines.
 This is useful for developers and you should include this output when
 submitting a bug report.
@item @strong{99}:  The debug output is additionally written to files in the @t{debug}
 directory. For each node (when running in parallel) there is a file called
 @t{debug_trace.<rank>}. Writing these files slows down the code by a huge factor and
 it is usually only necessary for parallel runs. In the serial case all
 the information can be obtained from standard out.
@end itemize

@c ----------------------------------
@item @strong{ExperimentalFeatures}@*
@vindex @code{ExperimentalFeatures}@*
@emph{Section}: Execution::Debug@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If true, allows the use of certain parts of the code that are
 still under development and are not suitable for production
 runs. This should not be used unless you know what you are doing.



@c ----------------------------------
@item @strong{ForceComplex}@*
@vindex @code{ForceComplex}@*
@emph{Section}: Execution::Debug@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* Normally @t{Octopus} determines automatically the type necessary
 for the wavefunctions. When set to yes this variable will
 force the use of complex wavefunctions.

 Warning: This variable is designed for testing and
 benchmarking and normal users need not use it.




@c ----------------------------------
@item @strong{MPIDebugHook}@*
@vindex @code{MPIDebugHook}@*
@emph{Section}: Execution::Debug@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* When debugging the code in parallel it is usually difficult to find the origin
 of race conditions that appear in MPI communications. This variable introduces
 a facility to control separate MPI processes. If set to yes, all nodes will
 start up, but will get trapped in an endless loop. In every cycle of the loop
 each node is sleeping for one second and is then checking if a file with the
 name @t{node_hook.xxx} (where @t{xxx} denotes the node number) exists. A given node can
 only be released from the loop if the corresponding file is created. This allows
 to selectively run, @emph{e.g.}, a compute node first followed by the master node. Or, by
 reversing the file creation of the node hooks, to run the master first followed
 by a compute node.



@c ----------------------------------
@item @strong{ReportMemory}@*
@vindex @code{ReportMemory}@*
@emph{Section}: Execution::Debug@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If true, @t{Octopus} will print as part of the screen output
 information about the memory the code is using. The quantity
 reported is an approximation to the size of the heap and
 generally it is a lower bound to the actual memory @t{Octopus} is
 using. By default this variable is set to false.



@c ----------------------------------
@end itemize
@node IO,,,
@subsection IO
@c ----------------------------------

@itemize
@item @strong{FlushMessages}@*
@vindex @code{FlushMessages}@*
@emph{Section}: Execution::IO@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* In addition to writing to stdout and stderr, the code messages may also be
 flushed to @t{messages.stdout} and @t{messages.stderr}, if this variable is
 set to yes.



@c ----------------------------------
@item @strong{RestartDir}@*
@vindex @code{RestartDir}@*
@emph{Section}: Execution::IO@*
@emph{Type}: string@*
@emph{Default}: ''@*
@* When @t{Octopus} reads restart files, e.g. when running a time-propagation
 after a ground-state calculation, these files will be read from
 @t{<RestartDir&gt/}. Usually, @t{RestartDir} is
 @t{TmpDir} but in a transport calculation, the output of
 a periodic dataset is required to calculate the extended ground state.



@c ----------------------------------
@item @strong{RestartWrite}@*
@vindex @code{RestartWrite}@*
@emph{Section}: Execution::IO@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* If this variable is set to no, restart information is not
 written. The default is yes.



@c ----------------------------------
@item @strong{TmpDir}@*
@vindex @code{TmpDir}@*
@emph{Section}: Execution::IO@*
@emph{Type}: string@*
@emph{Default}: "restart/"@*
@* The name of the directory where @t{Octopus} stores binary information
 such as the wavefunctions.



@c ----------------------------------
@item @strong{WorkDir}@*
@vindex @code{WorkDir}@*
@emph{Section}: Execution::IO@*
@emph{Type}: string@*
@emph{Default}: "."@*
@* By default, all files are written and read from the working directory,
 @emph{i.e.} the directory from which the executable was launched. This behavior can
 be changed by setting this variable: if you give it a name (other than ".")
 the files are written and read in that directory.



@c ----------------------------------
@item @strong{stderr}@*
@vindex @code{stderr}@*
@emph{Section}: Execution::IO@*
@emph{Type}: string@*
@emph{Default}: "-"@*
@* The standard error by default goes to, well, to standard error. This can
 be changed by setting this variable: if you give it a name (other than "-")
 the output stream is printed in that file instead.



@c ----------------------------------
@item @strong{stdout}@*
@vindex @code{stdout}@*
@emph{Section}: Execution::IO@*
@emph{Type}: string@*
@emph{Default}: "-"@*
@* The standard output by default goes to, well, to standard output. This can
 be changed by setting this variable: if you give it a name (other than "-")
 the output stream is printed in that file instead.



@c ----------------------------------
@end itemize
@node OpenCL,,,
@subsection OpenCL
@c ----------------------------------

@itemize
@item @strong{DisableOpenCL}@*
@vindex @code{DisableOpenCL}@*
@emph{Section}: Execution::OpenCL@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* If Octopus was compiled with OpenCL support, it will try to
 initialize and use an OpenCL device. By setting this variable
 to @t{yes} you tell Octopus not to use OpenCL.



@c ----------------------------------
@item @strong{OpenCLDevice}@*
@vindex @code{OpenCLDevice}@*
@emph{Section}: Execution::OpenCL@*
@emph{Type}: integer@*
@* This variable selects the OpenCL device that Octopus will
 use. You can specify one of the options below or a numerical
 id to select a specific device.


@emph{Options}:
@itemize @minus
@item @strong{gpu}:  If available, Octopus will use a GPU for OpenCL. This is the default.
@item @strong{cpu}:  If available, Octopus will use a GPU for OpenCL.
@item @strong{accelerator}:  If available, Octopus will use an accelerator for OpenCL.
@item @strong{cl_default}:  Octopus will use the default device specified by the OpenCL
 implementation.
@end itemize

@c ----------------------------------
@item @strong{OpenCLPlatform}@*
@vindex @code{OpenCLPlatform}@*
@emph{Section}: Execution::OpenCL@*
@emph{Type}: integer@*
@* This variable selects the OpenCL platform that Octopus will
 use. You can give an explicit platform number or use one of
 the options that select a particular vendor
 implementation. Platform 0 is used by default.


@emph{Options}:
@itemize @minus
@item @strong{amd}:  Use the AMD OpenCL platform.
@item @strong{nvidia}:  Use the Nvidia OpenCL platform.
@item @strong{ati}:  Use the ATI (old AMD) OpenCL platform.
@item @strong{intel}:  Use the Intel OpenCL platform.
@end itemize

@c ----------------------------------
@end itemize
@node Optimization,,,
@subsection Optimization
@c ----------------------------------

@itemize
@item @strong{MemoryLimit}@*
@vindex @code{MemoryLimit}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@emph{Default}: -1@*
@* If positive, @t{Octopus} will stop if more memory than @t{MemoryLimit}
 is requested (in kb). Note that this variable only works when
 @t{ProfilingMode = prof_memory(_full)}.



@c ----------------------------------
@item @strong{MeshBlockSize}@*
@vindex @code{MeshBlockSize}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: block@*
@* To improve memory-access locality when calculating derivatives,
 @t{Octopus} arranges mesh points in blocks. This variable
 controls the size of this blocks in the different
 directions. The default is | 20 | 20 | 100 |. (This variable only
 affects the performance of @t{Octopus} and not the
 results.)



@c ----------------------------------
@item @strong{OperateComplex}@*
@vindex @code{OperateComplex}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@emph{Default}: autodetect@*
@* This variable selects the subroutine used to apply non-local
 operators over the grid for complex functions.
 By default the optimized version is used.


@emph{Options}:
@itemize @minus
@item @strong{fortran}:  The standard Fortran function.
@item @strong{optimized}:  This version is optimized using vector primitives (if available).
@end itemize

@c ----------------------------------
@item @strong{OperateDouble}@*
@vindex @code{OperateDouble}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@emph{Default}: autodetect@*
@* This variable selects the subroutine used to apply non-local
 operators over the grid for real functions.
 By default the optimized version is used.


@emph{Options}:
@itemize @minus
@item @strong{fortran}:  The standard Fortran function.
@item @strong{optimized}:  This version is optimized using vector primitives (if available).
@end itemize

@c ----------------------------------
@item @strong{OperateOpenCL}@*
@vindex @code{OperateOpenCL}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@emph{Default}: split@*
@* This variable selects the subroutine used to apply non-local
 operators over the grid when opencl is used. The default is
 split.


@emph{Options}:
@itemize @minus
@item @strong{invmap}:  The standard implementation ported to OpenCL.
@item @strong{map}:  A different version, more suitable for GPUs.
@item @strong{split}:  This operator uses two different paths, one for points where
 the operator can be applied in blocks and other for single
 points.
@end itemize

@c ----------------------------------
@item @strong{OperateOpenCLVecSize}@*
@vindex @code{OperateOpenCLVecSize}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Selects the size of vectors for the OpenCL application of
 finite-difference operators. Valid values are 1, 2, 4, 8 and
 16. The default is 1.



@c ----------------------------------
@item @strong{ProfilingAllNodes}@*
@vindex @code{ProfilingAllNodes}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@emph{Default}: no@*
@* This variable controls whether all nodes print the time
 profiling output. If set to no, the default, only the root node
 will write the profile. If set to yes, all nodes will print it.



@c ----------------------------------
@item @strong{ProfilingMode}@*
@vindex @code{ProfilingMode}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@emph{Default}: no@*
@* Use this variable to run @t{Octopus} in profiling mode. In this mode
 @t{Octopus} records the time spent in certain areas of the code and
 the number of times this code is executed. These numbers
 are written in @t{./profiling.NNN/profiling.nnn} with @t{nnn} being the
 node number (@t{000} in serial) and @t{NNN} the number of processors.
 This is mainly for development purposes. Note, however, that
 @t{Octopus} should be compiled with @t{--disable-debug} to do proper
 profiling.


@emph{Options}:
@itemize @minus
@item @strong{no}:  No profiling information is generated.
@item @strong{prof_time}:  Profile the time spent in defined profiling regions.
@item @strong{prof_memory}:  As well as the time, memory usage is reported.
@item @strong{prof_memory_full}:  As well as the time, full memory usage is reported.
@end itemize

@c ----------------------------------
@item @strong{StatesBlockSize}@*
@vindex @code{StatesBlockSize}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@* Some routines work over blocks of eigenfunctions, which
 generally improves performance at the expense of increased
 memory consumption. This variable selects the size of the
 blocks to be used. If OpenCl is enabled, the default is 32;
 otherwise it is max(4, 2*nthreads).



@c ----------------------------------
@item @strong{StatesCLDeviceMemory}@*
@vindex @code{StatesCLDeviceMemory}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: float@*
@* This variable select the amount of OpenCL device memory that
 would be used by Octopus to store the states.

 A number smaller than 1 indicates a fraction of the total
 device memory. A number larger than one indicates an absolute
 amount of memory in megabytes. A negative number indicates an
 amount of memory in megabytes that would be substracted from
 the total device memory. The default is -512.




@c ----------------------------------
@item @strong{StatesOrthogonalization}@*
@vindex @code{StatesOrthogonalization}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@emph{Default}: gram_schmidt@*
@* The full orthogonalization method used by some
 eigensolvers. The default is gram_schmidt. With state
 parallelization the default is par_gram_schmidt.


@emph{Options}:
@itemize @minus
@item @strong{gram_schmidt}:  The standard Gram-Schmidt orthogonalization implemented using
 BLAS/LAPACK. Can be used with domain parallelization but not
 state parallelization.
@item @strong{par_gram_schmidt}:  The standard Gram-Schmidt orthogonalization implemented using
 ScaLAPACK. Compatible with states parallelization.
@item @strong{mgs}:  Modified Gram-Schmidt orthogonalization.
@item @strong{qr}:  (Experimental) Orthogonalization is performed based on a QR
 decomposition based on Lapack routines _getrf and _orgqr.
 Compatible with states parallelization.
@item @strong{old_gram_schmidt}:  Old Gram-Schmidt implementation, compatible with states
 parallelization.
@end itemize

@c ----------------------------------
@item @strong{StatesPack}@*
@vindex @code{StatesPack}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* (Experimental) When set to yes, states are stored in packed
 mode, which improves performance considerably. However this
 is not fully implemented and it might give wrong results. The
 default is no.

 If OpenCL is used and this variable is set to yes, Octopus
 will store the wave-functions in device (GPU) memory. If
 there is not enough memory to store all the wave-functions,
 execution will stop with an error.



@c ----------------------------------
@end itemize
@node Parallelization,,,
@subsection Parallelization
@c ----------------------------------

@itemize
@item @strong{MeshPartition}@*
@vindex @code{MeshPartition}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@* Decides which algorithm is used to partition the mesh. By default,
 @t{graph} partitioning is used for 8 or more partitions, and @t{rcb} for fewer.


@emph{Options}:
@itemize @minus
@item @strong{rcb}:  Recursive coordinate bisection partitioning.
@item @strong{rib}:  Recursive inertial bisection partitioning.
@item @strong{hsfc}:  Hilbert space-filling curve partitioning.
@item @strong{reftree}:  Refinement-tree-based partitioning.
@item @strong{graph}:  Graph partitioning.
@item @strong{hypergraph}:  Hypergraph partitioning.
@end itemize

@c ----------------------------------
@item @strong{MeshPartitionFromScratch}@*
@vindex @code{MeshPartitionFromScratch}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* If set to no (the default) Octopus will try to use the mesh
 partition from a previous run if available.



@c ----------------------------------
@item @strong{MeshPartitionGAMaxSteps}@*
@vindex @code{MeshPartitionGAMaxSteps}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@emph{Default}: 1000@*
@* The number of steps performed for the genetic algorithm used
 to optimize the mesh partition. The default is 1000.



@c ----------------------------------
@item @strong{MeshPartitionGAPopulation}@*
@vindex @code{MeshPartitionGAPopulation}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@emph{Default}: 30@*
@* The size of the population used for the genetic algorithm used
 to optimize the mesh partition. The default is 30.



@c ----------------------------------
@item @strong{MeshPartitionPackage}@*
@vindex @code{MeshPartitionPackage}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@emph{Default}: metis@*
@* Decides which library to use to perform the mesh partition. By
 default, METIS is used (if available).


@emph{Options}:
@itemize @minus
@item @strong{metis}:  METIS library.
@item @strong{zoltan}:  Zoltan library.
@item @strong{ga}:  (Experimental) Genetic-algorithm optimization of the grid partition.
@item @strong{pfft_part}:  (Experimental) Use PFFT to perform the mesh partition.
@end itemize

@c ----------------------------------
@item @strong{MeshPartitionStencil}@*
@vindex @code{MeshPartitionStencil}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@emph{Default}: star@*
@* To partition the mesh, it is necessary to calculate the connection
 graph connecting the points. This variable selects which stencil
 is used to do this. The default is the order-one star stencil.
 Alternatively, the stencil used for the Laplacian may be used.


@emph{Options}:
@itemize @minus
@item @strong{stencil_star}:  An order-one star stencil.
@item @strong{laplacian}:  The stencil used for the Laplacian is used to calculate the
 partition. This in principle should give a better partition, but
 it is slower and requires more memory.
@end itemize

@c ----------------------------------
@item @strong{MeshUseTopology}@*
@vindex @code{MeshUseTopology}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* (experimental) If enabled, @t{Octopus} will use an MPI virtual
 topology to map the processors. This can improve performance
 for certain interconnection systems.



@c ----------------------------------
@item @strong{ParallelizationGroupRanks}@*
@vindex @code{ParallelizationGroupRanks}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: block@*
@* Specifies the size of the groups used for the
 parallelization. For example (n_d, n_s, n_k) means we have
 @emph{n_p*n_s*n_k} processors and that the @emph{k}-points should be
 divided in @emph{n_k} groups, the states in @emph{n_s} groups, and each
 state in @emph{n_d} domains. You can pass the value @t{fill} to one
 field: it will be replaced by the value required to complete
 the number of processors in the run.


@emph{Options}:
@itemize @minus
@item @strong{fill}:  Replaced by the value required to complete the number of processors.
@end itemize

@c ----------------------------------
@item @strong{ParallelizationNumberSlaves}@*
@vindex @code{ParallelizationNumberSlaves}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@* Slaves are nodes used for task parallelization. The number of
 such nodes is given by this variable multiplied by the number
 of domains used in domain parallelization. The default is 0.



@c ----------------------------------
@item @strong{ParallelizationOfDerivatives}@*
@vindex @code{ParallelizationOfDerivatives}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@emph{Default}: non_blocking@*
@* This option selects how the communication of mesh boundaries is performed.


@emph{Options}:
@itemize @minus
@item @strong{blocking}:  Blocking communication.
@item @strong{non_blocking}:  Communication is based on non-blocking point-to-point communication. This is the default.
@end itemize

@c ----------------------------------
@item @strong{ParallelizationPoissonAllNodes}@*
@vindex @code{ParallelizationPoissonAllNodes}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* When running in parallel, this variable selects whether the
 Poisson solver should divide the work among all nodes or only
 among the parallelization-in-domains groups.



@c ----------------------------------
@item @strong{ParallelizationStrategy}@*
@vindex @code{ParallelizationStrategy}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: flag@*
@* Specifies what kind of parallelization strategy @t{Octopus} should use.
 The values can be combined: for example, @t{par_domains + par_states}
 means a combined parallelization in domains and states.
 Default: @t{par_domains + par_states} for @t{CalculationMode = td},
 @t{par_domains + par_other} for @t{CalculationMode = casida},
 otherwise @t{par_domains}.


@emph{Options}:
@itemize @minus
@item @strong{serial}:  @t{Octopus} will run in serial.
@item @strong{par_domains}:  @t{Octopus} will run parallel in domains.
@item @strong{par_states}:  @t{Octopus} will run parallel in states.
@item @strong{par_kpoints}:  @t{Octopus} will run parallel in @emph{k}-points/spin.
@item @strong{par_other}:  Run-mode-dependent. For example, in @t{casida}, it means parallelization in @emph{e-h} pairs.
@end itemize

@c ----------------------------------
@end itemize
@node Units,,,
@subsection Units
@c ----------------------------------

@itemize
@item @strong{Units}@*
@vindex @code{Units}@*
@emph{Section}: Execution::Units@*
@emph{Type}: integer@*
@emph{Default}: atomic@*
@* This variable selects the units that Octopus use for
 input and output.

 Atomic units seem to be the preferred system in the atomic and
 molecular physics community. Internally, the code works in
 atomic units. However, for input or output, some people like
 to use a system based in eV for energies and @math{\AA}
 for length. The default is atomic units.

 Normally time units are derived from energy and length units,
 so it is measured in @math{\hbar/Hartree} or
 @math{\hbar/electronvolt}. Alternatively you can tell
 Octopus to use femtoseconds as the time unit by adding the
 value @t{femtoseconds} (Note that no other unit will be
 based on femtoseconds). So for example you can use:

 @t{Units = femtoseconds}

 or

 @t{Units = ev_angstrom + femtoseconds}

 You can use different unit systems for input and output by
 setting the @t{UnitsInput} and @t{UnitsOutput}.

 Warning 1: All files read on input will also be treated using
 these units, including XYZ geometry files.

 Warning 2: Some values are treated in their most common units,
 for example atomic masses (a.m.u.), electron effective masses
 (electron mass), vibrational frequencies
 (cm<sup>-1</sup>) or temperatures (Kelvin). The unit of charge is always
 the electronic charge @emph{e}.



@emph{Options}:
@itemize @minus
@item @strong{atomic}:  Atomic units.
@item @strong{ev_angstrom}:  Electronvolts for energy, Angstroms for length, the rest of the
 units are derived from these and @math{hbar=1}.
@item @strong{femtoseconds}:  (Experimental) If you add this value to the other options,
 Octopus will treat time in femtoseconds units.
@end itemize

@c ----------------------------------
@item @strong{UnitsInput}@*
@vindex @code{UnitsInput}@*
@emph{Section}: Execution::Units@*
@emph{Type}: integer@*
@emph{Default}: atomic@*
@* Same as @t{Units}, but only refers to input values.



@c ----------------------------------
@item @strong{UnitsOutput}@*
@vindex @code{UnitsOutput}@*
@emph{Section}: Execution::Units@*
@emph{Type}: integer@*
@emph{Default}: atomic@*
@* Same as @t{Units}, but only refers to output values.



@c ----------------------------------
@end itemize
@node Hamiltonian,,,
@section Hamiltonian
@c ----------------------------------

@itemize
@item @strong{AtomsMagnetDirection}@*
@vindex @code{AtomsMagnetDirection}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: block@*
@* This option is only used when @t{GuessMagnetDensity} is
 set to @t{user_defined}. It provides a direction for the
 magnetization vector of each atom when building the guess
 density. In order to do that, the user should specify the
 coordinates of a vector that has the desired direction and
 norm.  Note that it is necessary to maintain the ordering in
 which the species were defined in the coordinates
 specifications.

 For spin-polarized calculations, the vectors should have only
 one component; for non-collinear-spin calculations, they
 should have three components.



@c ----------------------------------
@item @strong{CalculateSelfInducedMagneticField}@*
@vindex @code{CalculateSelfInducedMagneticField}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* The existence of an electronic current implies the creation of a self-induced magnetic
 field, which may in turn back-react on the system. Of course, a fully consistent treatment
 of this kind of effect should be done in QED theory, but we will attempt a first
 approximation to the problem by considering the lowest-order relativistic terms
 plugged into the normal Hamiltonian equations (spin-other-orbit coupling terms, etc.).
 For the moment being, none of this is done, but a first step is taken by calculating
 the induced magnetic field of a system that has a current, by considering the magnetostatic
 approximation and Biot-Savart law:

 @math{ \nabla^2 \vec{A} + 4\pi\alpha \vec{J} = 0}

 @math{ \vec{B} = \vec{\nabla} \times \vec{A}}

 If @t{CalculateSelfInducedMagneticField} is set to yes, this @emph{B} field is
 calculated at the end of a @t{gs} calculation (nothing is done -- yet -- in the @t{td }case)
 and printed out, if the @t{Output} variable contains the @t{potential} keyword (the prefix
 of the output files is @t{Bind}).



@c ----------------------------------
@item @strong{ClassicalPotential}@*
@vindex @code{ClassicalPotential}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: integer@*
@* Whether and how to add to the external potential the potential generated by
 the classical charges read from the PDB input (see @t{PBDCoordinates}).


@emph{Options}:
@itemize @minus
@item @strong{no}:   No classical charges.
@item @strong{point_charges}:   Classical charges are treated as point charges.
@item @strong{gaussian_smeared}:   Classical charges are treated as Gaussian distributions.
  Smearing widths are hard-coded by species (experimental).
@end itemize

@c ----------------------------------
@item @strong{ComplexScaling}@*
@vindex @code{ComplexScaling}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* (experimental) If set to yes, a complex scaled Hamiltonian will be used.
 When @t{TheoryLevel=DFT} Density functional resonance theory DFRT is employed.
 In order to reveal resonances @t{ComplexScalingAngle} bigger than zero should be set.
 D. L. Whitenack and A. Wasserman, Phys. Rev. Lett. 107, 163002 (2011).



@c ----------------------------------
@item @strong{ComplexScalingAngle}@*
@vindex @code{ComplexScalingAngle}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: float@*
@emph{Default}: 0.3@*
@* The complex scaling parameter theta in DFRT.
 It should be bound to 0 <= theta < pi/4.



@c ----------------------------------
@item @strong{CurrentDFT}@*
@vindex @code{CurrentDFT}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* (experimental) If set to yes, Current-DFT will be used. This is the
 extension to DFT that should be used when external magnetic fields are
 present. The current-dependent part of the XC functional is set using the
 @t{JFunctional} variable. The default is no.



@c ----------------------------------
@item @strong{FilterPotentials}@*
@vindex @code{FilterPotentials}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: integer@*
@emph{Default}: filter_none@*
@* @t{Octopus} can filter the pseudopotentials so that they no
 longer contain Fourier components larger than the mesh itself. This is
 very useful to decrease the egg-box effect, and so should be used in
 all instances where atoms move (@emph{e.g.} geometry optimization,
 molecular dynamics, and vibrational modes).


@emph{Options}:
@itemize @minus
@item @strong{filter_none}:  Do not filter.
@item @strong{filter_TS}:  The filter of M. Tafipolsky and R. Schmid, @emph{J. Chem. Phys.} @strong{124}, 174102 (2006).
@item @strong{filter_BSB}:  The filter of E. L. Briggs, D. J. Sullivan, and J. Bernholc, @emph{Phys. Rev. B} @strong{54}, 14362 (1996).
@end itemize

@c ----------------------------------
@item @strong{GaugeVectorField}@*
@vindex @code{GaugeVectorField}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: block@*
@* The gauge vector field is used to include a uniform (but time-dependent)
 external electric field in a time-dependent run for
 a periodic system. An optional second row specifies the initial
 value for the time derivative of the gauge field (which is set
 to zero by default). By default this field is not included.
 This is used with utility @t{oct-dielectric_function}
 according to GF Bertsch, J-I Iwata, A Rubio, and K Yabana,
 @emph{Phys. Rev. B} @strong{62}, 7998-8002 (2000).



@c ----------------------------------
@item @strong{GyromagneticRatio}@*
@vindex @code{GyromagneticRatio}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: float@*
@emph{Default}: 2.0023193043768@*
@* The gyromagnetic ratio of the electron. This is of course a physical
 constant, and the default value is the exact one that you should not
 touch, unless:
 (i)  You want to disconnect the anomalous Zeeman term in the Hamiltonian
 (then set it to zero; this number only affects that term);
 (ii) You are using an effective Hamiltonian, as is the case when
 you calculate a 2D electron gas, in which case you have an effective
 gyromagnetic factor that depends on the material.



@c ----------------------------------
@item @strong{IgnoreExternalIons}@*
@vindex @code{IgnoreExternalIons}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If this variable is set to "yes", then the ions that are outside the simulation box do not feel any
 external force (and therefore progress at constant velocity), and do not originate any force on other
 ions, or any potential on the electronic system.

 This feature is only available for finite systems; if the system is periodic in any dimension,
 this variable cannot be set to "yes".



@c ----------------------------------
@item @strong{MassScaling}@*
@vindex @code{MassScaling}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: block@*
@* Scaling factor for anisotropic masses (different masses along each
 geometric direction).

 @t{%MassScaling
 @*@ @ 1.0 | 1800.0 | 1800.0
 @*%}

 would fix the mass of the particles to be 1800 along the @emph{y} and @emph{z}
 directions. This can be useful, @emph{e.g.}, to simulate 3 particles in 1D,
 in this case an electron and 2 protons.




@c ----------------------------------
@item @strong{ParticleMass}@*
@vindex @code{ParticleMass}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* It is possible to make calculations for a particle with a mass
 different from one (atomic unit of mass, or mass of the electron).
 This is useful to describe non-electronic systems, or for
 esoteric purposes.



@c ----------------------------------
@item @strong{RelativisticCorrection}@*
@vindex @code{RelativisticCorrection}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: integer@*
@emph{Default}: non_relativistic@*
@* The default value means that @emph{no} relativistic correction is used. To
 include spin-orbit coupling turn @t{RelativisticCorrection} to @t{spin_orbit}
 (this will only work if @t{SpinComponents} has been set to @t{non_collinear}, which ensures
 the use of spinors).


@emph{Options}:
@itemize @minus
@item @strong{non_relativistic}:  No relativistic corrections.
@item @strong{spin_orbit}:  Spin-orbit.
@end itemize

@c ----------------------------------
@item @strong{SOStrength}@*
@vindex @code{SOStrength}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: float@*
@emph{Default}: 1@*
@* Tuning of the spin-orbit coupling strength: setting this value to zero turns off spin-orbit terms in
 the Hamiltonian, and setting it to one corresponds to full spin-orbit.



@c ----------------------------------
@item @strong{StaticElectricField}@*
@vindex @code{StaticElectricField}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: block@*
@* A static constant electric field may be added to the usual Hamiltonian,
 by setting the block @t{StaticElectricField}.
 The three possible components of the block (which should only have one
 line) are the three components of the electric field vector.
 It can be applied in a periodic direction of a large supercell via
 the single-point Berry phase.



@c ----------------------------------
@item @strong{StaticMagneticField}@*
@vindex @code{StaticMagneticField}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: block@*
@* A static constant magnetic field may be added to the usual Hamiltonian,
 by setting the block @t{StaticMagneticField}.
 The three possible components of the block (which should only have one
 line) are the three components of the magnetic field vector. Note that
 if you are running the code in 1D mode, this will not work, and if you
 are running the code in 2D mode the magnetic field will have to be in
 the @emph{z}-direction, so that the first two columns should be zero.

 The magnetic field should always be entered in atomic units, regardless
 of the @t{Units} variable. Note that we use the "Gaussian" system
 meaning 1 au[B] = 1.7152553 * 10^7 gauss, which corresponds to
 1.7152553 * 10^3 Tesla.



@c ----------------------------------
@item @strong{StaticMagneticField2DGauge}@*
@vindex @code{StaticMagneticField2DGauge}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: integer@*
@* The gauge of the static vector potential A when a magnetic field B = (0,0,B_z) is applied onto a 2D-system.


@emph{Options}:
@itemize @minus
@item @strong{linear_xy}:  Linear gauge with A = ((1/2)/P_c)*(-y,x)*B_z. This is the default.
@item @strong{linear_y}:  Linear gauge with A = (1/P_c)*(-y,0)*B_z
@end itemize

@c ----------------------------------
@item @strong{TheoryLevel}@*
@vindex @code{TheoryLevel}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: integer@*
@emph{Default}: dft@*
@* The calculations can be run with different "theory levels":


@emph{Options}:
@itemize @minus
@item @strong{hartree}:  Calculation within the Hartree method (experimental). Note that, contrary to popular
 belief, the Hartree potential is self-interaction-free. Therefore, this run
 mode will not yield the same result as @t{dft} without exchange-correlation.
@item @strong{independent_particles}:  Particles will be considered as independent, @emph{i.e.} as non-interacting.
 This mode is mainly used for testing purposes, as the code is usually
 much faster with @t{independent_particles}.
@item @strong{hartree_fock}:  This is the traditional Hartree-Fock scheme. Like the Hartree scheme, it is fully
 self-interaction-free. This mode is extremely slow. It is often more convenient
 to use @t{dft} within the OEP scheme to get similar (but not the same) results.
 Note that within this scheme you can use a correlation functional, or a hybrid
 functional (see @t{XCFunctional}). In the latter case, you will be following the
 quantum-chemistry recipe to use hybrids.
@item @strong{dft}:  This is the default density-functional theory scheme. Note that you can also use
 hybrids in this scheme, but they will be handled the "DFT" way, @emph{i.e.}, solving the
 OEP equation.
@item @strong{classical}:  (Experimental) Only the classical interaction between ions is
 considered. This is mainly for testing.
@item @strong{rdmft}:  (Not fully implemented) Reduced Density Matrix functional theory
@end itemize

@c ----------------------------------
@end itemize
@node Poisson,,,
@subsection Poisson
@c ----------------------------------

@itemize
@item @strong{AbsRelFMM}@*
@vindex @code{AbsRelFMM}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: integer@*
@emph{Default}: 2@*
@* Sets type of error bound.
 0 = 10^-3 relative error.
 1 = absolute delta_E error. The error (delta_E) is a fraction of the unity of energy
 2 = relative delta_E error. The error is the given ratio (delta_E) of the total energy
 > - Could you explain me what is the difference between considering relative
 > or absolute error in the calculations, and why you choose your default as
  > delta_E=E-3, absrel=relative?
 The default is just standard error, which fits most situations. It
 means, your energy has three significant digits. Lets say the energy of
 your system is 1000.0, then the FMM will compute results with a
 precision of +-1.
 So the result will be
 energy=999 ... 1001.
 If you change delta_E to 10^-6 it would be something in between
 energy=999.999 ... 1000.001
 If you do know the magnitude of your energy and set absrel to an
 absolute error the situation is different. Setting delta_E to 10^-2 means
 you will an energy=999.99..1000.01 which corresponds to 10^5 as
 relative error.
 Which one you choose is up to you. Since you want to calculate periodic
 systems, you may experience very precise results even if you set delta_E
 very low. It is a side effect from the periodicity (totalcharge=0), but
 should not bother you at all. You get this kind of extra precision for free.



@c ----------------------------------
@item @strong{AlphaFMM}@*
@vindex @code{AlphaFMM}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: float@*
@emph{Default}: 0.291262136@*
@* Parameter for the correction of the self-interaction of the
 electrostatic Hartree potential. The default value is 0.291262136.



@c ----------------------------------
@item @strong{DeltaEFMM}@*
@vindex @code{DeltaEFMM}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: float@*
@emph{Default}: 0.0001@*
@* Parameter for absolute or relative convergence of FMM.
 Sets energy error bound.
 Strong inhomogeneous systems may violate the error bound.
 For inhomogeneous systems we have an error-controlled sequential version available
 (from Ivo Kabadshow).



@c ----------------------------------
@item @strong{DipoleCorrection}@*
@vindex @code{DipoleCorrection}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: integer@*
@* Extrinsic/Intrinsic potential.
 If you want to compare to classical Ewald use 0 or 1.


@emph{Options}:
@itemize @minus
@item @strong{-1}:  Disables dipole correction.
@item @strong{0}:  FMM decides whether correction should be applied.
@item @strong{1}:  Apply dipole correction.
@end itemize

@c ----------------------------------
@item @strong{PoissonFFTKernel}@*
@vindex @code{PoissonFFTKernel}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: integer@*
@* Defines which kernel is used to impose the correct boundary
 condition when using FFTs to solve the Poisson equation. The
 default is selected depending on the dimensionality and
 periodicity of the system.


@emph{Options}:
@itemize @minus
@item @strong{spherical}:  FFTs using spherical cutoff (in 2D or 3D).
@item @strong{cylindrical}:  FFTs using cylindrical cutoff (in 3D).
@item @strong{planar}:  FFTs using planar cutoff (in 3D).
@item @strong{fft_nocut}:  FFTs without using a cutoff (in 3D).
@item @strong{multipole_correction}:  The boundary conditions are imposed by using a multipole expansion.
@end itemize

@c ----------------------------------
@item @strong{PoissonSolver}@*
@vindex @code{PoissonSolver}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: integer@*
@* Defines which method to use to solve the Poisson equation. Defaults:
 @* 1D and 2D: @t{fft}.
 @* 3D: @t{cg_corrected} if curvilinear, @t{isf} if not periodic, @t{fft} if periodic.


@emph{Options}:
@itemize @minus
@item @strong{direct1D}:  Direct evaluation of the Hartree potential (in 1D).
@item @strong{direct2D}:  Direct evaluation of the Hartree potential (in 2D).
@item @strong{direct3D}:  Direct evaluation of the Hartree potential (in 3D).
@item @strong{FMM}:  Fast multipole method.
@item @strong{NoPoisson}:  do not use a Poisson solver at all
@item @strong{fft}:  The Poisson equation is solved using FFTs. A cutoff technique
 for the Poisson kernel is selected so the proper boundary
 conditions are imposed according to the periodicity of the
 system. This can be overridden by the PoissonFFTKernel
 variable.
@item @strong{cg}:  Conjugate gradients.
@item @strong{cg_corrected}:  Corrected conjugate gradients.
@item @strong{multigrid}:  Multigrid method.
@item @strong{isf}:  Interpolating Scaling Functions Poisson solver.
@item @strong{sete}:  (Experimental) SETE solver.
@end itemize

@c ----------------------------------
@item @strong{PoissonSolverBoundaries}@*
@vindex @code{PoissonSolverBoundaries}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: integer@*
@* For finite systems, some Poisson solvers (@t{multigrid},
 @t{cg_corrected} and @t{fft_corrected}) require the calculation of the
 boundary conditions with an auxiliary method. This variable
 selects that method. The default is @t{multipole}.


@emph{Options}:
@itemize @minus
@item @strong{multipole}:  A multipole expansion of the density is used to approximate the potential on the boundaries.
@item @strong{exact}:  An exact integration of the Poisson equation is done over the boundaries.
@end itemize

@c ----------------------------------
@item @strong{PoissonSolverMaxIter}@*
@vindex @code{PoissonSolverMaxIter}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: integer@*
@emph{Default}: 400@*
@* The maximum number of iterations for conjugate-gradient
 Poisson solvers.



@c ----------------------------------
@item @strong{PoissonSolverMaxMultipole}@*
@vindex @code{PoissonSolverMaxMultipole}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: integer@*
@* Order of the multipolar expansion for boundary
 corrections. Default is 4 for @t{PoissonSolver = cg_corrected} and @t{multigrid} and 2
 for @t{fft_corrected}.



@c ----------------------------------
@item @strong{PoissonSolverNodes}@*
@vindex @code{PoissonSolverNodes}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: integer@*
@* How many nodes to use to solve the Poisson equation. A value of
 0, the default, implies that all available nodes are used.



@c ----------------------------------
@item @strong{PoissonSolverThreshold}@*
@vindex @code{PoissonSolverThreshold}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: float@*
@emph{Default}: 1e-5@*
@* The tolerance for the Poisson solution, used by the @t{cg} and
 @t{multigrid} solvers.



@c ----------------------------------
@end itemize
@node Multigrid,,,
@subsubsection Multigrid
@c ----------------------------------

@itemize
@item @strong{PoissonSolverMGMaxCycles}@*
@vindex @code{PoissonSolverMGMaxCycles}@*
@emph{Section}: Hamiltonian::Poisson::Multigrid@*
@emph{Type}: integer@*
@emph{Default}: 60@*
@* Maximum number of multigrid cycles that are performed if
 convergence is not achieved.



@c ----------------------------------
@item @strong{PoissonSolverMGPostsmoothingSteps}@*
@vindex @code{PoissonSolverMGPostsmoothingSteps}@*
@emph{Section}: Hamiltonian::Poisson::Multigrid@*
@emph{Type}: integer@*
@emph{Default}: 4@*
@* Number of Gauss-Seidel smoothing steps after coarse-level
 correction in the multigrid Poisson solver.



@c ----------------------------------
@item @strong{PoissonSolverMGPresmoothingSteps}@*
@vindex @code{PoissonSolverMGPresmoothingSteps}@*
@emph{Section}: Hamiltonian::Poisson::Multigrid@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Number of Gauss-Seidel smoothing steps before coarse-level
 correction in the multigrid Poisson solver.



@c ----------------------------------
@item @strong{PoissonSolverMGRelaxationFactor}@*
@vindex @code{PoissonSolverMGRelaxationFactor}@*
@emph{Section}: Hamiltonian::Poisson::Multigrid@*
@emph{Type}: float@*
@* Relaxation factor of the relaxation operator used for the
 multigrid method. This is mainly for debugging,
 since overrelaxation does not help in a multigrid scheme.
 The default is 1.0, except 0.6666 for the @t{gauss_jacobi} method.



@c ----------------------------------
@item @strong{PoissonSolverMGRelaxationMethod}@*
@vindex @code{PoissonSolverMGRelaxationMethod}@*
@emph{Section}: Hamiltonian::Poisson::Multigrid@*
@emph{Type}: integer@*
@* Method used to solve the linear system approximately in each grid for the
 multigrid procedure that solves Poisson equation. Default is @t{gauss_seidel},
 unless curvilinear coordinates are used, in which case the default is @t{gauss_jacobi}.


@emph{Options}:
@itemize @minus
@item @strong{gauss_seidel}:  Gauss-Seidel.
@item @strong{gauss_jacobi}:  Gauss-Jacobi.
@item @strong{gauss_jacobi2}:  Alternative implementation of Gauss-Jacobi.
@end itemize

@c ----------------------------------
@item @strong{PoissonSolverMGRestrictionMethod}@*
@vindex @code{PoissonSolverMGRestrictionMethod}@*
@emph{Section}: Hamiltonian::Poisson::Multigrid@*
@emph{Type}: integer@*
@emph{Default}: fullweight@*
@* Method used from fine-to-coarse grid transfer.


@emph{Options}:
@itemize @minus
@item @strong{injection}:  Injection
@item @strong{fullweight}:  Fullweight restriction
@end itemize

@c ----------------------------------
@end itemize
@node XC,,,
@subsection XC
@c ----------------------------------

@itemize
@item @strong{Interaction1D}@*
@vindex @code{Interaction1D}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@emph{Default}: interaction_soft_coulomb@*
@* When running in 1D, one has to soften the Coulomb interaction. This softening
 is not unique, and several possibilities exist in the literature.


@emph{Options}:
@itemize @minus
@item @strong{interaction_exp_screened}:  Exponentially screened Coulomb interaction.
 See, @emph{e.g.}, M Casula, S Sorella, and G Senatore, @emph{Phys. Rev. B} @strong{74}, 245427 (2006).
@item @strong{interaction_soft_coulomb}:  Soft Coulomb interaction of the form 1/sqrt(x^2 + alpha^2). This is the default.
@end itemize

@c ----------------------------------
@item @strong{Interaction1DScreening}@*
@vindex @code{Interaction1DScreening}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* Defines the screening parameter, alpha, of the softened Coulomb interaction
 when running in 1D. The default value is 1.0.



@c ----------------------------------
@item @strong{KSInversionLevel}@*
@vindex @code{KSInversionLevel}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@emph{Default}: ks_inversion_adiabatic@*
@* At what level shall @t{Octopus} handle the KS inversion


@emph{Options}:
@itemize @minus
@item @strong{ks_inversion_none}:  Do not compute KS inversion
@item @strong{ks_inversion_adiabatic}:  Compute exact adiabatic vxc
@end itemize

@c ----------------------------------
@item @strong{MGGAimplementation}@*
@vindex @code{MGGAimplementation}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@emph{Default}: mgga_gea@*
@* Decides how to implement the meta-GGAs (NOT WORKING).


@emph{Options}:
@itemize @minus
@item @strong{mgga_dphi}:  Use for @math{v_xc} the derivative of the energy functional with respect
 to @math{\phi^*(r)}. This is the approach used in most quantum-chemistry
 (and other) programs.
@item @strong{mgga_gea}:  Use gradient expansion (GEA) of the kinetic-energy density.
@item @strong{mgga_oep}:  Use the OEP equation to obtain the XC potential. This is the "correct" way
 to do it within DFT.
@end itemize

@c ----------------------------------
@item @strong{OEPLevel}@*
@vindex @code{OEPLevel}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@emph{Default}: oep_kli@*
@* At what level shall @t{Octopus} handle the optimized effective potential (OEP) equation.


@emph{Options}:
@itemize @minus
@item @strong{oep_none}:  Do not solve OEP equation.
@item @strong{oep_slater}:  Slater approximation.
@item @strong{oep_kli}:  Krieger-Li-Iafrate (KLI) approximation
 (JB Krieger, Y Li, GJ Iafrate, @emph{Phys. Rev. Lett. A} @strong{146}, 256 (1990).
@item @strong{oep_full}:  (Experimental) Full solution of OEP equation using the Sternheimer approach.
@end itemize

@c ----------------------------------
@item @strong{OEPMixing}@*
@vindex @code{OEPMixing}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* The linear mixing factor used to solve the Sternheimer
 equation in the full OEP procedure. The default is 1.0.



@c ----------------------------------
@item @strong{SICCorrection}@*
@vindex @code{SICCorrection}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@emph{Default}: sic_none@*
@* This variable controls which form of self-interaction correction to use. Note that
 this correction will be applied to the functional chosen by @t{XCFunctional}.


@emph{Options}:
@itemize @minus
@item @strong{sic_none}:  No self-interaction correction.
@item @strong{sic_pz}:  Perdew-Zunger SIC, handled by the OEP technique.
@item @strong{sic_amaldi}:  Amaldi correction term.
@end itemize

@c ----------------------------------
@item @strong{XCDensityCorrection}@*
@vindex @code{XCDensityCorrection}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@emph{Default}: none@*
@* This variable controls the long range correction of the XC
 potential using the XC density representation
 (http://arxiv.org/abs/1107.4339). By default, no correction
 is applied.


@emph{Options}:
@itemize @minus
@item @strong{none}:  No correction is applied.
@item @strong{long_range_x}:  The correction is applied to the exchange potential.
@end itemize

@c ----------------------------------
@item @strong{XCDensityCorrectionCutoff}@*
@vindex @code{XCDensityCorrectionCutoff}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* The value of the cutoff applied to the XC density. The default value is 0.



@c ----------------------------------
@item @strong{XCDensityCorrectionMinimum}@*
@vindex @code{XCDensityCorrectionMinimum}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* When enabled, the default, the cutoff optimization will
 return the first minimum of the q_xc function if it does
 not find a value of -1 (See http://arxiv.org/abs/1107.4339
 for details). This is required for atoms or small
 molecules, but may cause numerical problems.



@c ----------------------------------
@item @strong{XCDensityCorrectionNormalize}@*
@vindex @code{XCDensityCorrectionNormalize}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* When enabled, the default, the correction will be
 normalized to reproduce the exact boundary conditions of
 the XC potential.



@c ----------------------------------
@item @strong{XCDensityCorrectionOptimize}@*
@vindex @code{XCDensityCorrectionOptimize}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* When enabled, the default, the density cutoff will be
 optimized to replicate the boundary conditions of the exact
 XC potential. If the variable is set to no, the value of
 the cutoff must be given by the XCDensityCorrectionCutoff
 variable.



@c ----------------------------------
@item @strong{XCFunctional}@*
@vindex @code{XCFunctional}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@* Defines the exchange and correlation functional to be used;
 they should be specified as a sum of a correlation term and an
 exchange term. Defaults:
 @* 1D: lda_x_1d + lda_c_1d_csc
 @* 2D: lda_x_2d + lda_c_2d_amgb
 @* 3D: lda_x + lda_c_pz_mod


@emph{Options}:
@itemize @minus
@item @strong{none}:  Exchange and correlation set to zero.
@item @strong{lda_c_pz_mod}:  Perdew & Zunger (Modified)
@item @strong{gga_x_pbe}:  Perdew, Burke & Ernzerhof exchange
@item @strong{gga_x_pbe_r}:  Perdew, Burke & Ernzerhof exchange (revised)
@item @strong{gga_x_b86}:  Becke 86 Xalfa,beta,gamma
@item @strong{gga_x_herman}:  Herman et al original GGA
@item @strong{gga_x_b86_mgc}:  Becke 86 Xalfa,beta,gamma (with mod. grad. correction)
@item @strong{gga_x_b88}:  Becke 88
@item @strong{gga_x_g96}:  Gill 96
@item @strong{gga_x_pw86}:  Perdew & Wang 86
@item @strong{gga_x_pw91}:  Perdew & Wang 91
@item @strong{lda_c_ob_pz}:  Ortiz & Ballone (PZ)
@item @strong{gga_x_optx}:  Handy & Cohen OPTX 01
@item @strong{gga_x_dk87_r1}:  dePristo & Kress 87 (version R1)
@item @strong{gga_x_dk87_r2}:  dePristo & Kress 87 (version R2)
@item @strong{gga_x_lg93}:  Lacks & Gordon 93
@item @strong{gga_x_ft97_a}:  Filatov & Thiel 97 (version A)
@item @strong{gga_x_ft97_b}:  Filatov & Thiel 97 (version B)
@item @strong{gga_x_pbe_sol}:  Perdew, Burke & Ernzerhof exchange (solids)
@item @strong{gga_x_rpbe}:  Hammer, Hansen & Norskov (PBE-like)
@item @strong{gga_x_wc}:  Wu & Cohen
@item @strong{gga_x_mpw91}:  Modified form of PW91 by Adamo & Barone
@item @strong{lda_c_pw}:  Perdew & Wang
@item @strong{gga_x_am05}:  Armiento & Mattsson 05 exchange
@item @strong{gga_x_pbea}:  Madsen (PBE-like)
@item @strong{gga_x_mpbe}:  Adamo & Barone modification to PBE
@item @strong{gga_x_xpbe}:  xPBE reparametrization by Xu & Goddard
@item @strong{gga_x_2d_b86_mgc}:  Becke 86 MGC for 2D systems
@item @strong{gga_x_bayesian}:  Bayesian best fit for the enhancement factor
@item @strong{gga_x_pbe_jsjr}:  JSJR reparametrization by Pedroza, Silva & Capelle
@item @strong{gga_x_2d_b88}:  Becke 88 in 2D
@item @strong{gga_x_2d_b86}:  Becke 86 Xalfa,beta,gamma
@item @strong{gga_x_2d_pbe}:  Perdew, Burke & Ernzerhof exchange in 2D
@item @strong{gga_c_pbe}:  Perdew, Burke & Ernzerhof correlation
@item @strong{lda_c_pw_mod}:  Perdew & Wang (Modified)
@item @strong{gga_c_lyp}:  Lee, Yang & Parr
@item @strong{gga_c_p86}:  Perdew 86
@item @strong{gga_c_pbe_sol}:  Perdew, Burke & Ernzerhof correlation SOL
@item @strong{gga_c_pw91}:  Perdew & Wang 91
@item @strong{gga_c_am05}:  Armiento & Mattsson 05 correlation
@item @strong{gga_c_xpbe}:  xPBE reparametrization by Xu & Goddard
@item @strong{gga_c_lm}:  Langreth and Mehl correlation
@item @strong{gga_c_pbe_jrgx}:  JRGX reparametrization by Pedroza, Silva & Capelle
@item @strong{gga_x_optb88_vdw}:  Becke 88 reoptimized to be used with vdW functional of Dion et al
@item @strong{lda_c_ob_pw}:  Ortiz & Ballone (PW)
@item @strong{gga_x_pbek1_vdw}:  PBE reparametrization for vdW
@item @strong{gga_x_optpbe_vdw}:  PBE reparametrization for vdW
@item @strong{gga_x_rge2}:  Regularized PBE
@item @strong{gga_c_rge2}:  Regularized PBE
@item @strong{gga_x_rpw86}:  refitted Perdew & Wang 86
@item @strong{gga_x_kt1}:  Keal and Tozer version 1
@item @strong{gga_xc_kt2}:  Keal and Tozer version 2
@item @strong{gga_c_wl}:  Wilson & Levy
@item @strong{gga_c_wi}:  Wilson & Ivanov
@item @strong{lda_c_2d_amgb}:  Attacalite et al
@item @strong{lda_c_2d_prm}:  Pittalis, Rasanen & Marques correlation in 2D
@item @strong{gga_x_lb}:  van Leeuwen & Baerends
@item @strong{gga_xc_hcth_93}:  HCTH functional fitted to  93 molecules
@item @strong{gga_xc_hcth_120}:  HCTH functional fitted to 120 molecules
@item @strong{gga_xc_hcth_147}:  HCTH functional fitted to 147 molecules
@item @strong{gga_xc_hcth_407}:  HCTH functional fitted to 147 molecules
@item @strong{gga_xc_edf1}:  Empirical functionals from Adamson, Gill, and Pople
@item @strong{gga_xc_xlyp}:  XLYP functional
@item @strong{gga_xc_b97}:  Becke 97
@item @strong{gga_xc_b97_1}:  Becke 97-1
@item @strong{gga_xc_b97_2}:  Becke 97-2
@item @strong{gga_xc_b97_d}:  Grimme functional to be used with C6 vdW term
@item @strong{lda_c_vbh}:  von Barth & Hedin
@item @strong{gga_xc_b97_k}:  Boese-Martin for Kinetics
@item @strong{gga_xc_b97_3}:  Becke 97-3
@item @strong{gga_xc_pbe1w}:  Functionals fitted for water
@item @strong{gga_xc_mpwlyp1w}:  Functionals fitted for water
@item @strong{gga_xc_pbelyp1w}:  Functionals fitted for water
@item @strong{gga_xc_sb98_1a}:  Schmider-Becke 98 parameterization 1a
@item @strong{gga_xc_sb98_1b}:  Schmider-Becke 98 parameterization 1b
@item @strong{gga_xc_sb98_1c}:  Schmider-Becke 98 parameterization 1c
@item @strong{gga_xc_sb98_2a}:  Schmider-Becke 98 parameterization 2a
@item @strong{gga_xc_sb98_2b}:  Schmider-Becke 98 parameterization 2b
@item @strong{lda_c_1d_csc}:  Casula, Sorella, and Senatore 1D correlation
@item @strong{gga_xc_sb98_2c}:  Schmider-Becke 98 parameterization 2c
@item @strong{gga_x_lbm}:  van Leeuwen & Baerends modified
@item @strong{lda_x_2d}:  Exchange in 2D
@item @strong{lda_x}:  Exchange
@item @strong{lda_xc_teter93}:  Teter 93 parametrization
@item @strong{lda_c_wigner}:  Wigner parametrization
@item @strong{mgga_x_lta}:  Local tau approximation of Ernzerhof & Scuseria
@item @strong{mgga_x_tpss}:  Perdew, Tao, Staroverov & Scuseria exchange
@item @strong{mgga_x_m06l}:  Zhao, Truhlar exchange
@item @strong{mgga_x_gvt4}:  GVT4 from Van Voorhis and Scuseria (exchange part)
@item @strong{mgga_x_tau_hcth}:  tau-HCTH from Boese and Handy
@item @strong{mgga_x_br89}:  Becke-Roussel 89
@item @strong{mgga_x_bj06}:  Becke & Johnson correction to Becke-Roussel 89
@item @strong{mgga_x_tb09}:  Tran & Blaha correction to Becke & Johnson
@item @strong{mgga_x_rpp09}:  Rasanen, Pittalis, and Proetto correction to Becke & Johnson
@item @strong{mgga_x_2d_prhg07}:  Pittalis, Rasanen, Helbig, Gross Exchange Functional
@item @strong{mgga_x_2d_prhg07_prp10}:  PRGH07 with PRP10 correction
@item @strong{lda_x_1d}:  Exchange in 1D
@item @strong{lda_c_ml1}:  Modified LSD (version 1) of Proynov and Salahub
@item @strong{lda_c_ml2}:  Modified LSD (version 2) of Proynov and Salahub
@item @strong{mgga_c_tpss}:  Perdew, Tao, Staroverov & Scuseria correlation
@item @strong{mgga_c_vsxc}:  VSxc from Van Voorhis and Scuseria (correlation part)
@item @strong{lda_c_gombas}:  Gombas parametrization
@item @strong{lda_c_rpa}:  Random Phase Approximation
@item @strong{lca_omc}:  Orestes, Marcasso & Capelle
@item @strong{lca_lch}:  Lee, Colwell & Handy
@item @strong{lda_c_hl}:  Hedin & Lundqvist
@item @strong{hyb_gga_xc_b3pw91}:  The original hybrid proposed by Becke
@item @strong{hyb_gga_xc_b3lyp}:  The (in)famous B3LYP
@item @strong{hyb_gga_xc_b3p86}:  Perdew 86 hybrid similar to B3PW91
@item @strong{hyb_gga_xc_o3lyp}:  hybrid using the optx functional
@item @strong{hyb_gga_xc_mpw1k}:  mixture of mPW91 and PW91 optimized for kinetics
@item @strong{hyb_gga_xc_pbeh}:  aka PBE0 or PBE1PBE
@item @strong{hyb_gga_xc_b97}:  Becke 97
@item @strong{hyb_gga_xc_b97_1}:  Becke 97-1
@item @strong{hyb_gga_xc_b97_2}:  Becke 97-2
@item @strong{hyb_gga_xc_x3lyp}:  maybe the best hybrid
@item @strong{hyb_gga_xc_b1wc}:  Becke 1-parameter mixture of WC and PBE
@item @strong{hyb_gga_xc_b97_k}:  Boese-Martin for Kinetics
@item @strong{hyb_gga_xc_b97_3}:  Becke 97-3
@item @strong{hyb_gga_xc_mpw3pw}:  mixture with the mPW functional
@item @strong{hyb_gga_xc_b1lyp}:  Becke 1-parameter mixture of B88 and LYP
@item @strong{hyb_gga_xc_b1pw91}:  Becke 1-parameter mixture of B88 and PW91
@item @strong{hyb_gga_xc_mpw1pw}:  Becke 1-parameter mixture of mPW91 and PW91
@item @strong{hyb_gga_xc_mpw3lyp}:  mixture of mPW and LYP
@item @strong{hyb_gga_xc_sb98_1a}:  Schmider-Becke 98 parameterization 1a
@item @strong{hyb_gga_xc_sb98_1b}:  Schmider-Becke 98 parameterization 1b
@item @strong{hyb_gga_xc_sb98_1c}:  Schmider-Becke 98 parameterization 1c
@item @strong{hyb_gga_xc_sb98_2a}:  Schmider-Becke 98 parameterization 2a
@item @strong{hyb_gga_xc_sb98_2b}:  Schmider-Becke 98 parameterization 2b
@item @strong{hyb_gga_xc_sb98_2c}:  Schmider-Becke 98 parameterization 2c
@item @strong{lda_c_gl}:  Gunnarson & Lundqvist
@item @strong{gga_k_vw}:  von Weiszaecker correction to Thomas-Fermi
@item @strong{gga_k_ge2}:  Second-order gradient expansion (l = 1/9)
@item @strong{gga_k_golden}:  TF-lambda-vW form by Golden (l = 13/45)
@item @strong{gga_k_yt65}:  TF-lambda-vW form by Yonei and Tomishima (l = 1/5)
@item @strong{gga_k_baltin}:  TF-lambda-vW form by Baltin (l = 5/9)
@item @strong{gga_k_lieb}:  TF-lambda-vW form by Lieb (l = 0.185909191)
@item @strong{gga_k_absr1}:  gamma-TFvW form by Acharya et al [g = 1 - 1.412/N^(1/3)]
@item @strong{gga_k_absr2}:  gamma-TFvW form by Acharya et al [g = 1 - 1.332/N^(1/3)]
@item @strong{gga_k_gr}:  gamma-TFvW form by Gzquez and Robles
@item @strong{gga_k_ludena}:  gamma-TFvW form by Ludea
@item @strong{lda_k_tf}:  Thomas-Fermi kinetic energy functional
@item @strong{gga_k_gp85}:  gamma-TFvW form by Ghosh and Parr
@item @strong{gga_k_pearson}:  Pearson
@item @strong{gga_k_ol1}:  Ou-Yang and Levy v.1
@item @strong{gga_k_ol2}:  Ou-Yang and Levy v.2
@item @strong{gga_k_fr_b88}:  Fuentealba & Reyes (B88 version)
@item @strong{gga_k_fr_pw86}:  Fuentealba & Reyes (PW86 version)
@item @strong{lda_k_lp}:  Lee and Parr Gaussian ansatz
@item @strong{lda_c_xalpha}:  Slater Xalpha
@item @strong{rdmft_xc_m}:  RDMFT Mueller functional
@item @strong{lda_c_vwn}:  Vosko, Wilk, & Nussair
@item @strong{lda_xc_cmplx}:  LDA complex scaled exchange-correlation.
@item @strong{lda_c_vwn_rpa}:  Vosko, Wilk, & Nussair (RPA)
@item @strong{ks_inversion}:  Inversion of KS potential
@item @strong{lda_c_pz}:  Perdew & Zunger
@item @strong{oep_x}:  OEP: Exact exchange
@end itemize

@c ----------------------------------
@item @strong{XCKernel}@*
@vindex @code{XCKernel}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@emph{Default}: lda_x+lda_c_pz_mod@*
@* Defines the exchange-correlation kernel. Only LDA kernels are available currently.


@emph{Options}:
@itemize @minus
@item @strong{xc_functional}:  The same functional defined by @t{XCFunctional}.
@end itemize

@c ----------------------------------
@item @strong{XCTailCorrection}@*
@vindex @code{XCTailCorrection}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* (Experimental) This variable applies a correction to
 the value of the XC functional in near-zero-density regions.
 This zone might have numerical noise or it might
 even be set to zero by @t{libxc}.
 The correction is performed by forcing the "-1/@emph{r} behaviour" of the XC potential
 in the zones where the density is lower then @t{XCTailCorrectionTol}.



@c ----------------------------------
@item @strong{XCTailCorrectionCMDistance}@*
@vindex @code{XCTailCorrectionCMDistance}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@* (Experimental) This variable allows the application of the tail correction to the XC potential only where
 the distance of the local point from the center of mass of the system is greater than
 @t{XCTailCorrectionCMDistance}.



@c ----------------------------------
@item @strong{XCTailCorrectionDelay}@*
@vindex @code{XCTailCorrectionDelay}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@* (Experimental) This variable skips the application of the tail correction during the first calls of the
 subroutine that build the exchange-correlation potential (@t{XCTailCorrectionDelay} = number of calls skipped):



@c ----------------------------------
@item @strong{XCTailCorrectionLinkFactor}@*
@vindex @code{XCTailCorrectionLinkFactor}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: float@*
@emph{Default}: 1@*
@* (Experimental) This variable forces a smooth transition between the region where the values of the XC functional
 have been previously calculated and the region where the -1/@emph{r} correction has been applied.
 The region of the transition starts where the electronic total density reaches the value of
 (@t{XCTailCorrectionLinkFactor} * @t{XCTailCorrectionTol}) and ends where the density reaches
 the value of @t{XCTailCorrectionTol}.



@c ----------------------------------
@item @strong{XCTailCorrectionTol}@*
@vindex @code{XCTailCorrectionTol}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: float@*
@emph{Default}: 5e-12@*
@*


@c ----------------------------------
@end itemize
@node Linear Response,,,
@section Linear Response
@c ----------------------------------

@itemize
@item @strong{MagneticGaugeCorrection}@*
@vindex @code{MagneticGaugeCorrection}@*
@emph{Section}: Linear Response@*
@emph{Type}: integer@*
@emph{Default}: gipaw@*
@* For magnetic linear response: how to handle gauge-invariance in the description
 of the coupling of electrons to the magnetic field.


@emph{Options}:
@itemize @minus
@item @strong{none}:  No correction.
@item @strong{gipaw}:  GIPAW correction: C Pickard and F Mauri, @emph{Phys. Rev. Lett.} @strong{91}, 196401 (2003).
@item @strong{icl}:  ICL correction: S Ismail-Beigi, EK Chang, and SG Louie, @emph{Phys. Rev. Lett.} @strong{87}, 087402 (2001).
@end itemize

@c ----------------------------------
@item @strong{ResponseMethod}@*
@vindex @code{ResponseMethod}@*
@emph{Section}: Linear Response@*
@emph{Type}: integer@*
@emph{Default}: sternheimer@*
@* Some response properties can be calculated either via
 Sternheimer linear response or by using finite
 differences. You can use this variable to select how you want
 them to be calculated, it applies to @t{em_resp} and @t{vib_modes}
 calculation modes. By default, the Sternheimer linear-response
 technique is used.


@emph{Options}:
@itemize @minus
@item @strong{sternheimer}:  The linear response is obtained by solving a self-consistent
 Sternheimer equation for the variation of the orbitals. This
 is the recommended method.
@item @strong{finite_differences}:  Properties are calculated as a finite-differences derivative of
 the energy obtained by several ground-state calculations. This
 method, slow and limited only to static response, is kept
 mainly because it is simple and useful for testing purposes.
@end itemize

@c ----------------------------------
@end itemize
@node Casida,,,
@subsection Casida
@c ----------------------------------

@itemize
@item @strong{CasidaCalcTriplet}@*
@vindex @code{CasidaCalcTriplet}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* For a non-spin-polarized ground state, singlet or triplet excitations can be calculated
 using different matrix elements. Default is to calculate singlets. This variable has no
 effect for a spin-polarized calculation.



@c ----------------------------------
@item @strong{CasidaKohnShamStates}@*
@vindex @code{CasidaKohnShamStates}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: string@*
@emph{Default}: all states@*
@* The calculation of the excitation spectrum of a system in the Casida frequency-domain
 formulation of linear-response time-dependent density functional theory (TDDFT)
 implies the use of a basis set of occupied/unoccupied Kohn-Sham orbitals. This
 basis set should, in principle, include all pairs formed by all occupied states,
 and an infinite number of unoccupied states. In practice, one has to truncate this
 basis set, selecting a number of occupied and unoccupied states that will form the
 pairs. These states are specified with this variable. If there are, say, 15 occupied
 states, and one sets this variable to the value "10-18", this means that occupied
 states from 10 to 15, and unoccupied states from 16 to 18 will be considered.

 This variable is a string in list form, @emph{i.e.} expressions such as "1,2-5,8-15" are
 valid. You should include a non-zero number of unoccupied states and a non-zero number
 of occupied states.



@c ----------------------------------
@item @strong{CasidaMomentumTransfer}@*
@vindex @code{CasidaMomentumTransfer}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: block@*
@* Momentum-transfer vector for the calculation of the dynamic structure
 factor. When this variable is set, the transition rates are determined
 using an exponential operator instead of the normal dipole one.



@c ----------------------------------
@item @strong{CasidaQuadratureOrder}@*
@vindex @code{CasidaQuadratureOrder}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: integer@*
@emph{Default}: 5@*
@* Directionally averaged dynamic structure factor is calculated by
 averaging over the results from a set of @emph{q}-vectors. The vectors
 are generated using Gauss-Legendre quadrature scheme [see @emph{e.g.}
 K. Atkinson, @emph{J. Austral. Math. Soc.} @strong{23}, 332 (1982)], and this
 variable determines the order of the scheme.



@c ----------------------------------
@item @strong{CasidaTheoryLevel}@*
@vindex @code{CasidaTheoryLevel}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: flag@*
@emph{Default}: @t{eps_diff + petersilka + lrtddft_casida}@*
@* Choose which electron-hole matrix-based theory levels to use in calculating excitation energies.
 More than one may be used to take advantage of the significant commonality between the calculations.
 Only @t{eps_diff} is available for spinors. Note the restart data saved by each theory level
 is compatible with all the others.


@emph{Options}:
@itemize @minus
@item @strong{lrtddft_casida}:  The full Casida method.
 Ref: C Jamorski, ME Casida, and DR Salahub, @emph{J. Chem. Phys.} @strong{104}, 5134 (1996)
 and ME Casida, "Time-dependent density functional response theory for molecules,"
 in @emph{Recent Advances in Density Functional Methods}, edited by DE Chong, vol. 1
 of @emph{Recent Advances in Computational Chemistry}, pp. 155-192 (World Scientific,
 Singapore, 1995).
@item @strong{eps_diff}:  Difference of eigenvalues, @emph{i.e.} independent-particle approximation.
@item @strong{petersilka}:  The Petersilka approximation uses only the diagonal part of the Tamm-Dancoff matrix.
 This is acceptable if there is little mixing between single-particle transitions.
 Ref: M Petersilka, UJ Gossmann, and EKU Gross, @emph{Phys. Rev. Lett.} @strong{76}, 1212 (1996).
@item @strong{tamm_dancoff}:  The Tamm-Dancoff approximation uses only occupied-unoccupied transitions and not
 unoccupied-occupied transitions.
 Ref: S Hirata and M Head-Gordon, @emph{Chem. Phys. Lett.} @strong{314}, 291 (1999).
@item @strong{variational}:  Second-order constrained variational theory CV(2)-DFT.
 Ref: T Ziegler, M Seth, M Krykunov, J Autschbach, and F Wang,
 @emph{J. Chem. Phys.} @strong{130}, 154102 (2009).
@end itemize

@c ----------------------------------
@item @strong{CasidaTransitionDensities}@*
@vindex @code{CasidaTransitionDensities}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: string@*
@emph{Default}: write none@*
@* Specifies which transition densities are to be calculated and written down. The
 transition density for the many-body state @emph{n} will be written to a file called
 @t{rho0n} prefixed by the theory level.

 This variable is a string in list form, @emph{i.e.} expressions such as "1,2-5,8-15" are
 valid.



@c ----------------------------------
@end itemize
@node KdotP,,,
@subsection KdotP
@c ----------------------------------

@itemize
@item @strong{KdotPCalcSecondOrder}@*
@vindex @code{KdotPCalcSecondOrder}@*
@emph{Section}: Linear Response::KdotP@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* If true, calculates second-order response of wavefunctions as well as first-order response.
 Note that the second derivative of the Hamiltonian is NOT included in this calculation.



@c ----------------------------------
@item @strong{KdotPCalculateEffectiveMasses}@*
@vindex @code{KdotPCalculateEffectiveMasses}@*
@emph{Section}: Linear Response::KdotP@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* If true, uses @t{kdotp} perturbations of ground-state wavefunctions
 to calculate effective masses.



@c ----------------------------------
@item @strong{KdotPEta}@*
@vindex @code{KdotPEta}@*
@emph{Section}: Linear Response::KdotP@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Imaginary frequency added to Sternheimer equation which may improve convergence.
 Not recommended.



@c ----------------------------------
@item @strong{KdotPOccupiedSolutionMethod}@*
@vindex @code{KdotPOccupiedSolutionMethod}@*
@emph{Section}: Linear Response::KdotP@*
@emph{Type}: integer@*
@emph{Default}: sternheimer@*
@* Method of calculating the contribution of the projection of the
  linear-response wavefunctions in the occupied subspace.


@emph{Options}:
@itemize @minus
@item @strong{sternheimer_eqn}:  The Sternheimer equation is solved including the occupied subspace,
 to get the full linear-response wavefunctions.
@item @strong{sum_over_states}:  The Sternheimer equation is solved only in the unoccupied subspace,
 and a sum-over-states perturbation-theory expression is used to
 evaluate the contributions in the occupied subspace.
@end itemize

@c ----------------------------------
@item @strong{KdotPUseNonLocalPseudopotential}@*
@vindex @code{KdotPUseNonLocalPseudopotential}@*
@emph{Section}: Linear Response::KdotP@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* For testing purposes, set to false to ignore the term -i[r,V] in
 the k.p perturbation, which is due to non-local pseudopotentials.



@c ----------------------------------
@end itemize
@node Polarizabilities,,,
@subsection Polarizabilities
@c ----------------------------------

@itemize
@item @strong{BornChargeSumRuleCorrection}@*
@vindex @code{BornChargeSumRuleCorrection}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* Enforce the acoustic sum rule by distributing the excess sum of Born charges equally among the atoms.
 Sum rule: sum(iatom) Z*(iatom,idir,idir2) = Z_tot delta(idir1, idir2).
 Violation of the sum rule may be caused by inadequate spacing, box size, or @emph{k}-point sampling.



@c ----------------------------------
@item @strong{EMCalcBornCharges}@*
@vindex @code{EMCalcBornCharges}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Calculate linear-response Born effective charges from electric perturbation (experimental).



@c ----------------------------------
@item @strong{EMCalcRotatoryResponse}@*
@vindex @code{EMCalcRotatoryResponse}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Calculate circular-dichroism spectrum from electric perturbation,
 and write to file @t{rotatory_strength}.



@c ----------------------------------
@item @strong{EMEta}@*
@vindex @code{EMEta}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* The imaginary part of the frequency, effectively a Lorentzian broadening
 for peaks in the spectrum. It can help convergence of the SCF cycle for the
 Sternheimer equation when on a resonance, and it can be used as a positive
 infinitesimal to get the imaginary parts of response functions at poles.
 In units of energy. Cannot be negative.



@c ----------------------------------
@item @strong{EMForceNoKdotP}@*
@vindex @code{EMForceNoKdotP}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* If the system is periodic, by default wavefunctions from a previous @t{kdotp} run will
 be read, to be used in the formulas for the polarizability and
 hyperpolarizability in the quantum theory of polarization. For testing purposes,
 you can set this variable to true to disregard the @t{kdotp} run, and use the formulas
 for the finite system. This variable has no effect for a finite system.



@c ----------------------------------
@item @strong{EMFreqs}@*
@vindex @code{EMFreqs}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: block@*
@* This block defines for which frequencies the polarizabilities
 will be calculated. If it is not present, the static (omega = 0) response
 is calculated.

 Each row of the block indicates a sequence of frequency values, the
 first column is an integer that indicates the number of steps, the
 second number is the initial frequency, and the third number the final
 frequency. If the first number is one, then only the initial value is
 considered. The block can have any number of rows. Consider the next example:

 @t{%EMFreqs
 @*31 | 0.0 | 1.0
 @* 1 | 0.32
 @*%}




@c ----------------------------------
@item @strong{EMFreqsSort}@*
@vindex @code{EMFreqsSort}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* If true, the frequencies specified by the @t{EMFreqs} block are sorted, so that
 they are calculated in increasing order. Can be set to false to use the order as stated,
 in case this makes better use of available restart information.



@c ----------------------------------
@item @strong{EMHyperpol}@*
@vindex @code{EMHyperpol}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: block@*
@* This block describes the multiples of the frequency used for
 the dynamic hyperpolarizability. The results are written to the
 file @t{beta} in the directory for the first multiple.
 There must be three factors, summing to zero. For example,
 for second-harmonic generation, you could use
 @t{1 | 1 | -2}.



@c ----------------------------------
@item @strong{EMOccupiedResponse}@*
@vindex @code{EMOccupiedResponse}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Solve for full response without projector into unoccupied subspace.
 Not possible if there are partial occupations.



@c ----------------------------------
@item @strong{EMPerturbationType}@*
@vindex @code{EMPerturbationType}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: integer@*
@emph{Default}: electric@*
@* Which perturbation to consider for electromagnetic linear response.


@emph{Options}:
@itemize @minus
@item @strong{none}:  Zero perturbation, for use in testing.
@item @strong{electric}:  Electric perturbation used to calculate electric polarizabilities
 and hyperpolarizabilities.
@item @strong{magnetic}:  Magnetic perturbation used to calculate magnetic susceptibilities.
@end itemize

@c ----------------------------------
@item @strong{EMWavefunctionsFromScratch}@*
@vindex @code{EMWavefunctionsFromScratch}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Do not use saved linear-response wavefunctions from a previous run as starting guess.
 Instead initialize to zero as in @t{FromScratch}, but restart densities will still
 be used. Restart wavefunctions from a very different frequency can hinder convergence.



@c ----------------------------------
@item @strong{vdWNPoints}@*
@vindex @code{vdWNPoints}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: integer@*
@* How many points to use in the Gauss-Legendre integration to obtain the
 van der Waals coefficients. The default is 6.



@c ----------------------------------
@end itemize
@node SCF in LR calculations,,,
@subsection SCF in LR calculations
@c ----------------------------------

@itemize
@item @strong{LRConvAbsDens}@*
@vindex @code{LRConvAbsDens}@*
@emph{Section}: Linear Response::SCF in LR calculations@*
@emph{Type}: float@*
@emph{Default}: 1e-5@*
@* The tolerance in the variation of the density, to determine if
 the SCF for linear response is converged.



@c ----------------------------------
@item @strong{LRMaximumIter}@*
@vindex @code{LRMaximumIter}@*
@emph{Section}: Linear Response::SCF in LR calculations@*
@emph{Type}: integer@*
@emph{Default}: 200@*
@* The maximum number of SCF iterations to calculate response.



@c ----------------------------------
@item @strong{LRTolAdaptiveFactor}@*
@vindex @code{LRTolAdaptiveFactor}@*
@emph{Section}: Linear Response::SCF in LR calculations@*
@emph{Type}: float@*
@emph{Default}: 0.1@*
@* This factor controls how much the tolerance is decreased
 during the self-consistency process. Smaller values mean that
 tolerance is decreased faster.



@c ----------------------------------
@item @strong{LRTolIterWindow}@*
@vindex @code{LRTolIterWindow}@*
@emph{Section}: Linear Response::SCF in LR calculations@*
@emph{Type}: float@*
@emph{Default}: 10@*
@* Number of iterations necessary to reach the final tolerance



@c ----------------------------------
@item @strong{LRTolScheme}@*
@vindex @code{LRTolScheme}@*
@emph{Section}: Linear Response::SCF in LR calculations@*
@emph{Type}: integer@*
@emph{Default}: tol_adaptive@*
@* The scheme used to adjust the tolerance of the solver during
 the SCF iteration. For @t{kdotp} and magnetic @t{em_resp} modes, or
 whenever @t{HamiltonianVariation = V_ext_only}, the
 scheme is set to fixed, and this variable is ignored.


@emph{Options}:
@itemize @minus
@item @strong{tol_fixed}:  The solver tolerance is fixed for all the iterations; this
 improves convergence but increases the computational cost
@item @strong{tol_adaptive}:  The tolerance is increased according to the level of
 convergence of the SCF.
@item @strong{tol_linear}:  The tolerance decreases linearly for the first @t{LRTolIterWindow} iterations.
@item @strong{tol_exp}:  The tolerance decreases exponentially for the first @t{LRTolIterWindow} iterations.
@end itemize

@c ----------------------------------
@end itemize
@node Solver,,,
@subsection Solver
@c ----------------------------------

@itemize
@item @strong{LRTolFinalTol}@*
@vindex @code{LRTolFinalTol}@*
@emph{Section}: Linear Response::Solver@*
@emph{Type}: float@*
@emph{Default}: 1e-6@*
@* This is the tolerance to determine that the linear solver has converged.



@c ----------------------------------
@item @strong{LRTolInitTol}@*
@vindex @code{LRTolInitTol}@*
@emph{Section}: Linear Response::Solver@*
@emph{Type}: float@*
@emph{Default}: 1e-2@*
@* This is the tolerance to determine that the linear solver has converged,
 for the first SCF iteration. Ignored if @t{LRTolScheme = fixed}.



@c ----------------------------------
@item @strong{LinearSolver}@*
@vindex @code{LinearSolver}@*
@emph{Section}: Linear Response::Solver@*
@emph{Type}: integer@*
@emph{Default}: qmr_symmetric@*
@* Method for solving linear equations, which occur for Sternheimer linear
 response and OEP. The solvers vary in speed, reliability (ability to
 converge), and domain of applicability. QMR solvers are most reliable.


@emph{Options}:
@itemize @minus
@item @strong{bicgstab}:  Biconjugate gradients stabilized. Slower than @t{cg}, but more reliable.
 General matrices.
@item @strong{cg}:  Conjugate gradients. Fast but unreliable. Hermitian matrices only
 (no eta in Sternheimer).
@item @strong{multigrid}:  Multigrid solver, currently only Gauss-Jacobi (experimental).
 Slow, but fairly reliable. General matrices.
@item @strong{qmr_symmetric}:  Quasi-minimal residual solver, for (complex) symmetric matrices. [Real symmetric
 is equivalent to Hermitian.] Slightly slower than @t{bicgstab} but more reliable.
 For Sternheimer, must be real wavefunctions, but can have eta.
@item @strong{qmr_symmetrized}:  Quasi-minimal residual solver, using the symmetrized form A^T A x = A^T y instead of
 A x = y. Reliable but very slow. General matrices.
@item @strong{qmr_dotp}:  Quasi-minimal residual solver, for Hermitian matrices, using the
 symmetric algorithm with conjugated dot product (experimental). Slightly slower than @t{bicgstab}
 but more reliable. Can always be used in Sternheimer.
@item @strong{qmr_general}:  Quasi-minimal residual solver, for general matrices, using the
 most general form of the algorithm. Slow and unreliable.
@item @strong{sos}:  Sum over states: the Sternheimer equation is solved by using
 the explicit solution in terms of the ground-state
 wavefunctions. You need unoccupied states to use this method.
 Unlike the other methods, may not give the correct answer.
@end itemize

@c ----------------------------------
@item @strong{LinearSolverMaxIter}@*
@vindex @code{LinearSolverMaxIter}@*
@emph{Section}: Linear Response::Solver@*
@emph{Type}: integer@*
@emph{Default}: 1000@*
@* Maximum number of iterations the linear solver does, even if
 convergence is not achieved.



@c ----------------------------------
@end itemize
@node Static Polarization,,,
@subsection Static Polarization
@c ----------------------------------

@itemize
@item @strong{EMCalcDiagonalField}@*
@vindex @code{EMCalcDiagonalField}@*
@emph{Section}: Linear Response::Static Polarization@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* Calculate @emph{yz}-field for beta_@emph{xyz} hyperpolarizability, which is sometimes harder to converge.
 Only applies if @t{ResponseMethod = finite_differences}.



@c ----------------------------------
@item @strong{EMStartDensityIsZeroField}@*
@vindex @code{EMStartDensityIsZeroField}@*
@emph{Section}: Linear Response::Static Polarization@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* Use the charge density from the zero-field calculation as the starting density for
 SCF calculations with applied fields. For small fields, this will be fastest.
 If there is trouble converging with larger fields, set to false,
 to initialize the calculation for each field from scratch, as specified by the LCAO variables.
 Only applies if @t{ResponseMethod = finite_differences}.



@c ----------------------------------
@item @strong{EMStaticElectricField}@*
@vindex @code{EMStaticElectricField}@*
@emph{Section}: Linear Response::Static Polarization@*
@emph{Type}: float@*
@emph{Default}: 0.01 a.u.@*
@* Magnitude of the static electric field used to calculate the static polarizability,
 if @t{ResponseMethod = finite_differences}.



@c ----------------------------------
@item @strong{EMVerbose}@*
@vindex @code{EMVerbose}@*
@emph{Section}: Linear Response::Static Polarization@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Write full SCF output.
 Only applies if @t{ResponseMethod = finite_differences}.



@c ----------------------------------
@item @strong{EMWriteRestartDensities}@*
@vindex @code{EMWriteRestartDensities}@*
@emph{Section}: Linear Response::Static Polarization@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* Write density after each calculation for restart, rather than just the resulting electronic dipole moment.
 Only applies if @t{ResponseMethod = finite_differences}. Restarting from calculations at smaller
 fields can be helpful if there are convergence problems.



@c ----------------------------------
@end itemize
@node Sternheimer,,,
@subsection Sternheimer
@c ----------------------------------

@itemize
@item @strong{HamiltonianVariation}@*
@vindex @code{HamiltonianVariation}@*
@emph{Section}: Linear Response::Sternheimer@*
@emph{Type}: integer@*
@emph{Default}: hartree+fxc@*
@* The terms to be considered in the variation of the
 Hamiltonian. The external potential (V_ext) is always considered. The default is to include
 also the exchange-correlation and Hartree terms, which fully
 takes into account local fields.
 Just @t{hartree} gives you the random-phase approximation (RPA).
 If you want to choose the exchange-correlation kernel, use the variable
 @t{XCKernel}. For @t{kdotp} and magnetic @t{em_resp} modes,
 or if @t{TheoryLevel = independent_particles},
 the value @t{V_ext_only} is used and this variable is ignored.


@emph{Options}:
@itemize @minus
@item @strong{V_ext_only}:  Neither Hartree nor XC potentials included.
@item @strong{hartree}:  The variation of the Hartree potential only.
@item @strong{fxc}:  The exchange-correlation kernel (the variation of the
 exchange-correlation potential) only.
@end itemize

@c ----------------------------------
@item @strong{Preorthogonalization}@*
@vindex @code{Preorthogonalization}@*
@emph{Section}: Linear Response::Sternheimer@*
@emph{Type}: logical@*
@* Whether initial linear-response wavefunctions should be orthogonalized
 or not against the occupied states, at the start of each SCF cycle.
 Default is true only if @t{SmearingFunction = semiconducting},
 or if the @t{Occupations} block specifies all full or empty states,
 and we are not solving for linear response in the unoccupied subspace only.



@c ----------------------------------
@end itemize
@node Vibrational Modes,,,
@subsection Vibrational Modes
@c ----------------------------------

@itemize
@item @strong{CalcInfrared}@*
@vindex @code{CalcInfrared}@*
@emph{Section}: Linear Response::Vibrational Modes@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* If set to true, infrared intensities (and Born charges) will be calculated
 and written in @t{vib_modes/infrared}.



@c ----------------------------------
@item @strong{CalcNormalModeWfs}@*
@vindex @code{CalcNormalModeWfs}@*
@emph{Section}: Linear Response::Vibrational Modes@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* If set to true, the response wavefunctions for each normal mode will be calculated
 and written in directory @t{restart/vib_modes/phn_nm_wfs_XXXXX}.
 This part is time-consuming and not parallel, but not needed for most purposes.



@c ----------------------------------
@item @strong{Displacement}@*
@vindex @code{Displacement}@*
@emph{Section}: Linear Response::Vibrational Modes@*
@emph{Type}: float@*
@emph{Default}: 0.01 a.u.@*
@* When calculating phonon properties by finite differences (@t{CalculationMode = vib_modes,
 ResponseMethod = finite_differences}),
 @t{Displacement} controls how much the atoms are to be moved in order to calculate the
 dynamical matrix.



@c ----------------------------------
@item @strong{SymmetrizeDynamicalMatrix}@*
@vindex @code{SymmetrizeDynamicalMatrix}@*
@emph{Section}: Linear Response::Vibrational Modes@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* If set to true, all entries of the dynamical matrix will be calculated and then
 the matrix will be symmetrized to enforce mat(i,j) = mat(j,i). If set to false,
 only the upper half of the matrix will be calculated.



@c ----------------------------------
@item @strong{UseRestartDontSolve}@*
@vindex @code{UseRestartDontSolve}@*
@emph{Section}: Linear Response::Vibrational Modes@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* If set to true, the restart info for each displacement will be used as is
 in calculating normal modes, without trying to solve the Sternheimer equation.
 This allows continuation of a previous calculation which did not complete
 without doing anything at all with the displacements already solved, since
 setting up the Sternheimer problem can be quite time-consuming for large systems.
 Use with care: if the stored info is not the appropriate converged solution,
 results will be incorrect.
 If @t{FromScratch = true}, this variable is always false.



@c ----------------------------------
@end itemize
@node General,,,
@subsection General
@c ----------------------------------

@itemize
@item @strong{ODESolver}@*
@vindex @code{ODESolver}@*
@emph{Section}: Math::General@*
@emph{Type}: integer@*
@emph{Default}: ode_rk4@*
@* Specifies what kind of ODE solver will be used.


@emph{Options}:
@itemize @minus
@item @strong{ode_rk4}:  Standard Runge-Kutta, 4th order.
@item @strong{ode_fb78}:  Fehlberg solver.
@item @strong{ode_vr89}:  Verner solver.
@item @strong{ode_pd89}:  Prince-Dormand solver.
@end itemize

@c ----------------------------------
@item @strong{ODESolverNSteps}@*
@vindex @code{ODESolverNSteps}@*
@emph{Section}: Math::General@*
@emph{Type}: integer@*
@emph{Default}: 100@*
@* Number of steps which the chosen ODE solver should perform
 in the integration interval [a,b] of the ODE.



@c ----------------------------------
@item @strong{RootSolver}@*
@vindex @code{RootSolver}@*
@emph{Section}: Math::General@*
@emph{Type}: integer@*
@emph{Default}: root_newton@*
@* Specifies what kind of root solver will be used.


@emph{Options}:
@itemize @minus
@item @strong{root_bisection}:  Bisection method.
@item @strong{root_brent}:  Brent method.
@item @strong{root_newton}:  Newton method.
@item @strong{root_laguerre}:  Laguerre method.
@item @strong{root_watterstrom}:  Watterstrom method.
@end itemize

@c ----------------------------------
@item @strong{RootSolverAbsTolerance}@*
@vindex @code{RootSolverAbsTolerance}@*
@emph{Section}: Math::General@*
@emph{Type}: float@*
@emph{Default}: 1e-8@*
@* Relative tolerance for the root-finding process.



@c ----------------------------------
@item @strong{RootSolverHavePolynomial}@*
@vindex @code{RootSolverHavePolynomial}@*
@emph{Section}: Math::General@*
@emph{Type}: logical@*
@emph{Default}: no@*
@*  If set to yes, the coefficients of the polynomial have to be passed to
  the root solver.



@c ----------------------------------
@item @strong{RootSolverMaxIter}@*
@vindex @code{RootSolverMaxIter}@*
@emph{Section}: Math::General@*
@emph{Type}: integer@*
@emph{Default}: 100@*
@* In case of an iterative root solver, this variable determines the maximum number
 of iteration steps.



@c ----------------------------------
@item @strong{RootSolverRelTolerance}@*
@vindex @code{RootSolverRelTolerance}@*
@emph{Section}: Math::General@*
@emph{Type}: float@*
@emph{Default}: 1e-8@*
@* Relative tolerance for the root-finding process.



@c ----------------------------------
@item @strong{RootSolverWSRadius}@*
@vindex @code{RootSolverWSRadius}@*
@emph{Section}: Math::General@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* Radius of circle in the complex plane. If @t{RootSolverWSRadius = 1.0},
 the unit roots of an @emph{n}th-order polynomial are taken as initial values.



@c ----------------------------------
@item @strong{SPARSKITAbsTolerance}@*
@vindex @code{SPARSKITAbsTolerance}@*
@emph{Section}: Math::General@*
@emph{Type}: float@*
@emph{Default}: 1e-8@*
@* Some SPARSKIT solvers use an absolute tolerance as a stopping criterion
 for the iterative solution process. This variable can be used to
 specify the tolerance.



@c ----------------------------------
@item @strong{SPARSKITIterOut}@*
@vindex @code{SPARSKITIterOut}@*
@emph{Section}: Math::General@*
@emph{Type}: integer@*
@* Determines how often status info of the solver is printed.



@c ----------------------------------
@item @strong{SPARSKITKrylovSubspaceSize}@*
@vindex @code{SPARSKITKrylovSubspaceSize}@*
@emph{Section}: Math::General@*
@emph{Type}: integer@*
@emph{Default}: 15@*
@* Some of the SPARSKIT solvers are Krylov subspace methods.
 This variable determines what size the solver will use
 for the subspace.



@c ----------------------------------
@item @strong{SPARSKITMaxIter}@*
@vindex @code{SPARSKITMaxIter}@*
@emph{Section}: Math::General@*
@emph{Type}: integer@*
@* This variable controls the maximum number of iteration steps that
 will be performed by the (iterative) linear solver.



@c ----------------------------------
@item @strong{SPARSKITRelTolerance}@*
@vindex @code{SPARSKITRelTolerance}@*
@emph{Section}: Math::General@*
@emph{Type}: float@*
@emph{Default}: 1e-8@*
@* Some SPARSKIT solvers use a relative tolerance as a stopping criterion
 for the iterative solution process. This variable can be used to
 specify the tolerance.



@c ----------------------------------
@item @strong{SPARSKITSolver}@*
@vindex @code{SPARSKITSolver}@*
@emph{Section}: Math::General@*
@emph{Type}: integer@*
@emph{Default}: sk_cg@*
@* Specifies what kind of linear solver will be used.


@emph{Options}:
@itemize @minus
@item @strong{sk_dqgmres}:  Direct versions of the Quasi-Generalized Minimum Residual method
@item @strong{sk_cg}:  Conjugate Gradient Method
@item @strong{sk_cgnr}:  Conjugate Gradient Method (Normal Residual equation)
@item @strong{sk_bcg}:  Bi-Conjugate Gradient Method
@item @strong{sk_dbcg}:  BCG with partial pivoting
@item @strong{sk_bcgstab}:  BCG stabilized
@item @strong{sk_tfqmr}:  Transpose-Free Quasi-Minimum Residual method
@item @strong{sk_fom}:  Full Orthogonalization Method
@item @strong{sk_gmres}:  Generalized Minimum Residual method
@item @strong{sk_fgmres}:  Flexible version of Generalized Minimum Residual method
@end itemize

@c ----------------------------------
@item @strong{SPARSKITVerboseSolver}@*
@vindex @code{SPARSKITVerboseSolver}@*
@emph{Section}: Math::General@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* When set to yes, the SPARSKIT solver will write more detailed output.



@c ----------------------------------
@item @strong{WatterstromODESolver}@*
@vindex @code{WatterstromODESolver}@*
@emph{Section}: Math::General@*
@emph{Type}: integer@*
@emph{Default}: ode_pd89@*
@* The Watterstrom method (@emph{J. Comp. Phys.} @strong{8}, 304-308 (1971)) transforms
 finding roots for @emph{n}th-order polynomials into the solution of @emph{n} uncoupled
 ODEs. This variable specifies the solver that should be used for the ODE
 stepping. Valid solver types are those allowed for the @t{ODESolver} variable.


@emph{Options}:
@itemize @minus
@item @strong{ode_rk4}:  Standard 4th-order Runge-Kutta.
@item @strong{ode_fb78}:  Fehlberg solver.
@item @strong{ode_vr89}:  Verner solver.
@item @strong{ode_pd89}:  Prince-Dormand solver.
@end itemize

@c ----------------------------------
@item @strong{WatterstromODESolverNSteps}@*
@vindex @code{WatterstromODESolverNSteps}@*
@emph{Section}: Math::General@*
@emph{Type}: integer@*
@emph{Default}: 400@*
@* Number of steps which the chosen ODE solver should perform
 in the integration interval [@emph{a}, @emph{b}] of the Watterstrom ODE.



@c ----------------------------------
@end itemize
@node Mesh,,,
@section Mesh
@c ----------------------------------

@itemize
@item @strong{DoubleGrid}@*
@vindex @code{DoubleGrid}@*
@emph{Section}: Mesh@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* Enables or disables the use of a double-grid technique to
 increase the precision of the application of the
 pseudopotentials.



@c ----------------------------------
@item @strong{DoubleGridOrder}@*
@vindex @code{DoubleGridOrder}@*
@emph{Section}: Mesh@*
@emph{Type}: integer@*
@emph{Default}: 9@*
@* Order of the interpolation used for the double grid. Must be
 an odd number. Low-order interpolation schemes are not
 recommended. The default is to use 9th-order interpolation.



@c ----------------------------------
@item @strong{MultiResolutionArea}@*
@vindex @code{MultiResolutionArea}@*
@emph{Section}: Mesh@*
@emph{Type}: block@*
@* (Experimental) Multiresolution regions are set with this
 parameter. The first three numbers define the central
 point of the region, and the following ones set
 the radii where resolution changes (measured from the
 central point).
 NOTE: currently, only one area can be set up, and only works in 3D.



@c ----------------------------------
@item @strong{MultiResolutionInterpolationOrder}@*
@vindex @code{MultiResolutionInterpolationOrder}@*
@emph{Section}: Mesh@*
@emph{Type}: integer@*
@emph{Default}: 5@*
@* The interpolation order in multiresolution approach. The default is 5.



@c ----------------------------------
@item @strong{MultigridLevels}@*
@vindex @code{MultigridLevels}@*
@emph{Section}: Mesh@*
@emph{Type}: integer@*
@* Number of levels in the grid hierarchy used for multigrid. Positive
 numbers indicate an absolute number of levels, negative
 numbers are subtracted to maximum number of levels possible for
 the grid been used. Default is the maximum number of levels for
 the grid.


@emph{Options}:
@itemize @minus
@item @strong{max_levels}:  Calculate the optimal number of levels for the grid.
@end itemize

@c ----------------------------------
@item @strong{OpenBoundaries}@*
@vindex @code{OpenBoundaries}@*
@emph{Section}: Mesh@*
@emph{Type}: block@*
@* This feature is experimental.
 In transport mode it enables open boundaries in the @emph{x}-direction
 and defines the character of the leads attached to the left and right
 of the finite central system.
 The more general situation (non-transport) is that a given number
 of leads (number_leads) are attached to the central region.

 The format is as follows:

 <pre>
 %OpenBoundaries
  lead_dataset     | "dataset"   | "dataset"
  lead_restart_dir | "directory" | "directory"
  lead_static_dir  | "directory" | "directory"
  add_unit_cells   | nl          | nr
  td_pot_formula   | "formula"   | "formula"
  transport_mode   | transport_on
  number_leads     | 2
 %
 </pre>

 The left column specifies characteristics of the left lead and
 and the right column characteristics of the right lead analogously.
 If only one column is given, the value specified is used for both leads.

 All entries except @t{lead_dataset} are optional.



@emph{Options}:
@itemize @minus
@item @strong{transport_off}:  Just use open boundaries.
@item @strong{lead_dataset}:  Gives the name of the dataset used for the periodic calculation of the
 ground states of the leads. It is used, @emph{e.g.}, to read in the coordinates of the
 atoms of the lead. Both entries for left and right have to be equal.
@item @strong{transport_on}:  Use transport (default).
@item @strong{lead_restart_dir}:  @t{lead_restart_dir} gives the name of restart directory of the periodic
 ground-state calculation for the lead unit cell. Though
 one may give different datasets for the left and right lead, they have to
 be identical due to the algorithm used to obtain extended eigenstates.
 The default is @t{<lead_dataset>restart}.
@item @strong{lead_static_dir}:  The same as @t{lead_restart_dir} for the @t{static} directory.
 @t{Octopus} needs the Kohn-Sham potential of the leads. Therefore, the periodic
 run must include @t{Output = potential} in the input file. The default
 of this entry is @t{<lead_dataset>static}.
@item @strong{add_unit_cells}:  @t{add_unit_cells} specifies how many lead unit cells should
 be included in the computational domain. Suitable values highly depend
 on the system under study but the numbers @t{nl} and @t{nr} should
 be taken large enough for the potential to equilibrate because we assume
 instaneous metallic screening in the leads. Furthermore, note that in
 a ground-state calculation, one additional unit cell is added automatically
 for each lead to the computational domain because the propagation
 algorithm needs the knowledge of the initial state for the first unit cell
 outside the simulation box. If omitted, no unit cells are included in the
 simulation region (apart from the one which is automatically added in
 ground-state calculations).
@item @strong{td_pot_formula}:  Defines a spatially local time-dependent potential in the leads as an
 analytic expression. This describes the time-dependent bias in the leads.
@item @strong{transport_mode}:  If set to on (transport_on) the normal transport calculation is done,
 otherwise (transport_off) an open system without the source term.
 The initial state is to be assumed to be completely localized in
 the central region. Default is transport_on.
@item @strong{number_leads}:  In the non-transport mode it defines the number of leads connected
 to the central region.

@end itemize

@c ----------------------------------
@item @strong{Spacing}@*
@vindex @code{Spacing}@*
@emph{Section}: Mesh@*
@emph{Type}: float@*
@* The spacing between the points in the mesh. If using curvilinear
 coordinates, this is a canonical spacing that will be changed locally by the
 transformation. In periodic directions, your spacing may be slightly larger than
 what you request here, since the box size must be an integer multiple of the spacing.

 It is possible to have a different spacing in each one of the Cartesian directions
 if we define @t{Spacing} as block of the form

 @t{%Spacing
 @*@ @ spacing_x | spacing_y | spacing_z
 @*%}



@c ----------------------------------
@item @strong{UseFineMesh}@*
@vindex @code{UseFineMesh}@*
@emph{Section}: Mesh@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If enabled, @t{Octopus} will use a finer mesh for the calculation
 of the forces or other sensitive quantities. The default is no.



@c ----------------------------------
@end itemize
@node Curvilinear,,,
@subsection Curvilinear
@c ----------------------------------

@itemize
@item @strong{CurvMethod}@*
@vindex @code{CurvMethod}@*
@emph{Section}: Mesh::Curvilinear@*
@emph{Type}: integer@*
@emph{Default}: curv_uniform@*
@* The relevant functions in octopus are represented on a mesh in real space.
 This mesh may be an evenly spaced regular rectangular grid (standard mode),
 or else an *adaptive* or *curvilinear grid*. We have implemented
 three kinds of adaptive meshes, although only one is currently working,
 the one invented by F. Gygi (@t{curv_gygi}). The code will stop if any of
 the other two is invoked.


@emph{Options}:
@itemize @minus
@item @strong{curv_uniform}:  Regular, uniform rectangular grid. The default.
@item @strong{curv_gygi}:  The deformation of the grid is done according to the scheme described by
 F. Gygi [F. Gygi and G. Galli, @emph{Phys. Rev. B} @strong{52}, R2229 (1995)].
@item @strong{curv_briggs}:  The deformation of the grid is done according to the scheme described by
 Briggs [E.L. Briggs, D.J. Sullivan, and J. Bernholc, @emph{Phys. Rev. B} @strong{54} 14362 (1996)]
 (NOT WORKING).
@item @strong{curv_modine}:  The deformation of the grid is done according to the scheme described by
 Modine [N.A. Modine, G. Zumbach and E. Kaxiras, @emph{Phys. Rev. B} @strong{55}, 10289 (1997)]
 (NOT WORKING).
@end itemize

@c ----------------------------------
@end itemize
@node Gygi,,,
@subsubsection Gygi
@c ----------------------------------

@itemize
@item @strong{CurvGygiA}@*
@vindex @code{CurvGygiA}@*
@emph{Section}: Mesh::Curvilinear::Gygi@*
@emph{Type}: float@*
@emph{Default}: 0.5@*
@* The grid spacing is reduced locally around each atom, and the reduction is
 given by 1/(1+@emph{A}), where @emph{A} is specified by this variable. So, if
 @emph{A}=1/2 (the default), the grid spacing is reduced to two thirds = 1/(1+1/2).
 [This is the @math{A_{\alpha}} variable in Eq. 2 of F. Gygi and G. Galli, @emph{Phys.
 Rev. B} @strong{52}, R2229 (1995)]. It must be larger than zero.



@c ----------------------------------
@item @strong{CurvGygiAlpha}@*
@vindex @code{CurvGygiAlpha}@*
@emph{Section}: Mesh::Curvilinear::Gygi@*
@emph{Type}: float@*
@emph{Default}: 2.0 a.u.@*
@* This number determines the region over which the grid is enhanced (range of
 enhancement of the resolution). That is, the grid is enhanced on a sphere
 around each atom, whose radius is given by this variable. [This is the @math{a_{\alpha}}
 variable in Eq. 2 of F. Gygi and G. Galli, @emph{Phys. Rev. B} @strong{52}, R2229 (1995)].
 It must be larger than zero.



@c ----------------------------------
@item @strong{CurvGygiBeta}@*
@vindex @code{CurvGygiBeta}@*
@emph{Section}: Mesh::Curvilinear::Gygi@*
@emph{Type}: float@*
@emph{Default}: 4.0 a.u.@*
@* This number determines the distance over which Euclidean coordinates are
 recovered. [This is the @math{b_{\alpha}} variable in Eq. 2 of F. Gygi and G. Galli,
 @emph{Phys. Rev. B} @strong{52}, R2229 (1995)]. It must be larger than zero.



@c ----------------------------------
@end itemize
@node Derivatives,,,
@subsection Derivatives
@c ----------------------------------

@itemize
@item @strong{DerivativesOrder}@*
@vindex @code{DerivativesOrder}@*
@emph{Section}: Mesh::Derivatives@*
@emph{Type}: integer@*
@emph{Default}: 4@*
@* This variable gives the discretization order for the approximation of
 the differential operators. This means, basically, that
 @t{DerivativesOrder} points are used in each positive/negative
 spatial direction, @emph{e.g.} @t{DerivativesOrder = 1} would give
 the well-known three-point formula in 1D.
 The number of points actually used for the Laplacian
 depends on the stencil used:

 @t{stencil_star}: 2*@t{DerivativesOrder}*@emph{dim}+1

 @t{stencil_cube}: (2*@t{DerivativesOrder}+1)^@emph{dim}

 @t{stencil_starplus}: 2*@t{DerivativesOrder}+1+@emph{n} with @emph{n} being 12
 in 2D and 44 in 3D.



@c ----------------------------------
@item @strong{DerivativesStencil}@*
@vindex @code{DerivativesStencil}@*
@emph{Section}: Mesh::Derivatives@*
@emph{Type}: integer@*
@emph{Default}: stencil_star@*
@* Decides what kind of stencil is used, @emph{i.e.} which points, around
 each point in the mesh, are the neighboring points used in the
 expression of the differential operator.

 If curvilinear coordinates are to be used, then only the @t{stencil_starplus}
 or the @t{stencil_cube} may be used. We only recommend the @t{stencil_starplus},
 since the cube typically needs way too much memory resources.


@emph{Options}:
@itemize @minus
@item @strong{stencil_star}:  A star around each point (@emph{i.e.}, only points on the axis).
@item @strong{stencil_variational}:  Same as the star, but with coefficients built in a different way.
@item @strong{stencil_cube}:  A cube of points around each point.
@item @strong{stencil_starplus}:  The star, plus a number of off-axis points.
@end itemize

@c ----------------------------------
@end itemize
@node FFTs,,,
@subsection FFTs
@c ----------------------------------

@itemize
@item @strong{DoubleFFTParameter}@*
@vindex @code{DoubleFFTParameter}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: float@*
@emph{Default}: 2.0@*
@* For solving the Poisson equation in Fourier space, and for applying the local potential
 in Fourier space, an auxiliary cubic mesh is built. This mesh will be larger than
 the circumscribed cube of the usual mesh by a factor @t{DoubleFFTParameter}. See
 the section that refers to Poisson equation, and to the local potential for details
 [the default value of two is typically good].



@c ----------------------------------
@item @strong{FFTLibrary}@*
@vindex @code{FFTLibrary}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: logical@*
@emph{Default}: fftw@*
@* (experimental) You can select the FFT library to use.


@emph{Options}:
@itemize @minus
@item @strong{fftw}:  Uses FFTW3 library.
@item @strong{pfft}:  (experimental) Uses PFFT library, which has to be linked.
@item @strong{clfft}:  (experimental) Uses clAmdFft (GPU) library, which has to be linked.
@end itemize

@c ----------------------------------
@item @strong{FFTOptimize}@*
@vindex @code{FFTOptimize}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* Should @t{octopus} optimize the FFT dimensions?
 This means that the mesh to which FFTs are applied is not taken to be as small
 as possible: some points may be added to each direction in order to get a "good number"
 for the performance of the FFT algorithm.
 The best FFT grid dimensions are given by @math{2^a*3^b*5^c*7^d*11^e*13^f}
 where @math{a,b,c,d} are arbitrary and @math{e,f} are 0 or 1.
 (http://www.fftw.org/doc/Complex-DFTs.html)
 In some cases, namely when using
 the split-operator, or Suzuki-Trotter propagators, this option should be turned off.
 For spatial FFTs in periodic directions, the grid is never optimized, but a warning will
 be written if the number is not good, with a suggestion of a better one to use, so you
 can try a different spacing if you want to get a good number.



@c ----------------------------------
@item @strong{FFTPreparePlan}@*
@vindex @code{FFTPreparePlan}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: integer@*
@emph{Default}: fftw_measure@*
@* The FFTs are performed in octopus with the help of the FFTW package (http://www.fftw.org).
 Before doing the actual computations, this package prepares a "plan", which means that
 the precise numerical strategy to be followed to compute the FFT is machine/compiler-dependent,
 and therefore the software attempts to figure out which is this precise strategy (see the
 FFTW documentation for details). This plan preparation, which has to be done for each particular
 FFT shape, can be done exhaustively and carefully (slow), or merely estimated. Since this is
 a rather critical numerical step, by default it is done carefully, which implies a longer initial
 initialization, but faster subsequent computations. You can change this behaviour by changing
 this @t{FFTPreparePlan} variable, and in this way you can force FFTW to do a fast guess or
 estimation of which is the best way to perform the FFT.


@emph{Options}:
@itemize @minus
@item @strong{fftw_measure}:  This is the default, and implies a longer initialization, but involves a more careful analysis
 of the strategy to follow, and therefore more efficient FFTs.
@item @strong{fftw_estimate}:  This is the "fast initialization" scheme, in which the plan is merely guessed from "reasonable"
 assumptions.
@end itemize

@c ----------------------------------
@item @strong{NFFTCutoff}@*
@vindex @code{NFFTCutoff}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: integer@*
@emph{Default}: 6@*
@* Cut-off parameter of the window function.
 See NFFT manual for details.



@c ----------------------------------
@item @strong{NFFTGuruInterface}@*
@vindex @code{NFFTGuruInterface}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Perform NFFT with guru interface. This permits the fine tuning of several critical parameters.



@c ----------------------------------
@item @strong{NFFTOversampling}@*
@vindex @code{NFFTOversampling}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: float@*
@emph{Default}: 2@*
@* NFFT oversampling factor (sigma). This will rule the size of the FFT under the hood.



@c ----------------------------------
@item @strong{NFFTPrecompute}@*
@vindex @code{NFFTPrecompute}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: integer@*
@emph{Default}: NFFT_PRE_PSI@*
@* NFFT precomputation strategy.


@emph{Options}:
@itemize @minus
@item @strong{NFFT_PRE_PSI}:  This method uses a medium amount of memory to store d*(2*m+1)*M real numbers and requires at most
 2(2m + 1)d extra multiplications for each node.
 This is the default option.
@item @strong{NFFT_PRE_FULL_PSI}:  Is the fastest method but requires a large amount of memory as it requires to store (2*m+1)^d*M
 real numbers. No extra operations are needed during matrix vector multiplication.
@item @strong{NFFT_PRE_LIN_PSI}:  This method implements a linear interpolation from a lookup table.
@end itemize

@c ----------------------------------
@end itemize
@node KPoints,,,
@subsection KPoints
@c ----------------------------------

@itemize
@item @strong{KPoints}@*
@vindex @code{KPoints}@*
@emph{Section}: Mesh::KPoints@*
@emph{Type}: block@*
@* This block defines an explicit set of @emph{k}-points and their weights for
 a periodic-system calculation. The first column is the weight
 of each @emph{k}-point and the following are the components of the @emph{k}-point
 vector. You only need to specify the components for the
 periodic directions. Note that the @emph{k}-points should be given in
 Cartesian coordinates (not in reduced coordinates), @emph{i.e.}
 what @t{Octopus} writes in a line in the ground-state standard output as
 @t{#k =   1, k = (    0.154000,    0.154000,    0.154000)}.

 For example, if you want to include only the Gamma point, you can
 use:

 @t{%KPoints
 @*@ @ 1.0 | 0 | 0 | 0
 @*%}




@c ----------------------------------
@item @strong{KPointsGrid}@*
@vindex @code{KPointsGrid}@*
@emph{Section}: Mesh::KPoints@*
@emph{Type}: block@*
@emph{Default}: Gamma-point only@*
@* When this block is given (and the @t{KPoints} block is not present),
 @emph{k}-points are distributed in a uniform grid.

 The first row of the block is a triplet of integers defining
 the number of @emph{k}-points to be used along each direction
 in reciprocal space. The numbers refer to the whole Brillouin
 zone, and the actual number of @emph{k}-points is usually
 reduced exploiting the symmetries of the system.  By default
 the grid will always include the Gamma point. An optional
 second row can specify a shift in the @emph{k}-points.

 For example, the following input samples the BZ with 100 points in the
 @emph{xy}-plane of reciprocal space:

 @t{%KPointsGrid
 @*@ @ 10 | 10 | 1
 @*%}




@c ----------------------------------
@item @strong{KPointsReduced}@*
@vindex @code{KPointsReduced}@*
@emph{Section}: Mesh::KPoints@*
@emph{Type}: block@*
@* Same as the block @t{KPoints} but this time the input is given in reduced
 coordinates.



@c ----------------------------------
@item @strong{KPointsUseSymmetries}@*
@vindex @code{KPointsUseSymmetries}@*
@emph{Section}: Mesh::KPoints@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* This variable defines whether symmetries are taken into account
 or not for the choice of @emph{k}-points. If it is set to no, the @emph{k}-point
 sampling will range over the full Brillouin zone.

 The default is no.

 When a perturbation is applied to the system, the full
 symmetries of the system cannot be used. In this case you must
 not use symmetries or use the @t{SymmetryBreakDir} to tell
 Octopus the direction of the perturbation (for the moment this
 has to be done by hand by the user, in the future it will be
 automatic).




@c ----------------------------------
@item @strong{KPointsUseTimeReversal}@*
@vindex @code{KPointsUseTimeReversal}@*
@emph{Section}: Mesh::KPoints@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* If symmetries are used to reduce the number of @emph{k}-points,
 this variable defines whether time-reversal symmetry is taken
 into account or not. If it is set to no, the @emph{k}-point
 sampling will not be reduced according to time-reversal
 symmetry.

 The default is yes, unless symmetries are broken in one
 direction by the SymmetryBreakDir block.

 Warning: For time propagation runs with an external field,
 time-reversal symmetry should not be used.




@c ----------------------------------
@end itemize
@node Simulation Box,,,
@subsection Simulation Box
@c ----------------------------------

@itemize
@item @strong{BoxOffset}@*
@vindex @code{BoxOffset}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Shifts the zero of the simulation box, relative to the atomic coordinates, by a specified vector.
 It can be either a float, interpreted as (x,x,x), or a block containing the (x,y,z) value of the zero.
 WARNING: This variable does not seem to work correctly!



@c ----------------------------------
@item @strong{BoxShape}@*
@vindex @code{BoxShape}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: integer@*
@emph{Default}: minimum@*
@* This variable decides the shape of the simulation box.
 Note that some incompatibilities apply:
 @itemize

 @item
Spherical or minimum mesh is not allowed for periodic systems.
 @item
Cylindrical mesh is not allowed for systems that are periodic in more than one dimension.
 @item
@t{Box_image} is only allowed in 2D.
 @end itemize



@emph{Options}:
@itemize @minus
@item @strong{sphere}:  The simulation box will be a sphere of radius @t{Radius}.
@item @strong{cylinder}:  The simulation box will be a cylinder with radius @t{Radius} and height two times
 @t{Xlength}.
@item @strong{minimum}:  The simulation box will be constructed by adding spheres created around each
 atom (or user-defined potential), of radius @t{Radius}.
@item @strong{parallelepiped}:  The simulation box will be a parallelepiped whose dimensions are taken from
 the variable @t{Lsize}.
@item @strong{box_image}:  The simulation box will be defined through an image. White means that the point
 is contained in the simulation box, while any other color means that the point is out.
@item @strong{hypercube}:  (experimental) The simulation box will be a hypercube or
 hyperparallelepiped. This is equivalent to the
 @t{parallelepiped} box but it can work with an arbitrary
 number of dimensions.
@item @strong{user_defined}:  The shape of the simulation box will be read from the variable @t{BoxShapeUsDef}.
@end itemize

@c ----------------------------------
@item @strong{BoxShapeImage}@*
@vindex @code{BoxShapeImage}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: string@*
@* Name of the file that contains the image that defines the simulation box.



@c ----------------------------------
@item @strong{BoxShapeUsDef}@*
@vindex @code{BoxShapeUsDef}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: string@*
@* Boolean expression that defines the interior of the simulation box. For example,
 @t{BoxShapeUsDef = "(sqrt(x^2+y^2) <= 4) && z>-2 && z<2"} defines a cylinder
 with axis parallel to the @emph{z}-axis.



@c ----------------------------------
@item @strong{LatticeVectors}@*
@vindex @code{LatticeVectors}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: block@*
@emph{Default}: simple cubic@*
@* Primitive lattice vectors. Vectors are stored in rows.
 Note that these vectors will be normalized to 1 after being read.
 Default:
 @t{%LatticeVectors
 @*@ @ 1.0 | 0.0 | 0.0
 @*@ @ 0.0 | 1.0 | 0.0
 @*@ @ 0.0 | 0.0 | 1.0
 @*%}



@c ----------------------------------
@item @strong{Lsize}@*
@vindex @code{Lsize}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: block@*
@* If @t{BoxShape} is @t{parallelepiped}, @t{hypercube},
 @t{box_image}, or @t{user_defined}, this is a
 block of the form:

 @t{%Lsize
 @*@ @ sizex | sizey | sizez | ...
 @*%}

 where the @t{size*} are half the lengths of the box in each direction.

 The number of columns must match the dimensionality of the
 calculation. If you want a cube you can also set @t{Lsize} as a
 single variable.



@c ----------------------------------
@item @strong{Radius}@*
@vindex @code{Radius}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: float@*
@* Defines the radius for @t{BoxShape} = @t{sphere}, @t{cylinder}, or @t{minimum}.
 Must be a positive number. If not specified, the code will look for values in
 the @t{Species} block, or, if default pseudopotentials are used, the @t{rsize} column of
 @t{share/PP/defaults}. In these cases, for @t{minimum}, a different radius is used for each species,
 while for other shapes, the maximum radius is used.



@c ----------------------------------
@item @strong{SymmetryBreakDir}@*
@vindex @code{SymmetryBreakDir}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: block@*
@* This variable specifies a direction in which the symmetry of
 the system will be broken. This is useful for generating @emph{k}-point
 grids when an external perturbation is applied.



@c ----------------------------------
@item @strong{Xlength}@*
@vindex @code{Xlength}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: float@*
@* If @t{BoxShape} is @t{cylinder}, the total length of the cylinder is twice @t{Xlength}.
 The default is @t{Radius}.



@c ----------------------------------
@end itemize
@node Open Boundaries,,,
@section Open Boundaries
@c ----------------------------------

@itemize
@item @strong{OpenBoundariesAdditionalTerms}@*
@vindex @code{OpenBoundariesAdditionalTerms}@*
@emph{Section}: Open Boundaries@*
@emph{Type}: flag@*
@emph{Default}: mem_term + src_term@*
@* The open-boundaries propagator inserts two additional terms in
 the Crank-Nicholson scheme: source and memory. With this variable,
 one or both of them can be switched off.



@emph{Options}:
@itemize @minus
@item @strong{mem_term}:  If present, include memory term in propagator
@item @strong{src_term}:  If present, include source term in propagator
@end itemize

@c ----------------------------------
@item @strong{OpenBoundariesMaxMemCoeffs}@*
@vindex @code{OpenBoundariesMaxMemCoeffs}@*
@emph{Section}: Open Boundaries@*
@emph{Type}: integer@*
@emph{Default}: TDMaximumIter@*
@* Sets the maximum number of used memory coefficients.
 Can be used to pre-calculate memory coefficients.



@c ----------------------------------
@item @strong{OpenBoundariesMemType}@*
@vindex @code{OpenBoundariesMemType}@*
@emph{Section}: Open Boundaries@*
@emph{Type}: integer@*
@emph{Default}: save_cpu_time@*
@* Decides whether the memory coefficients use lots of RAM (default)
 or uses a more compact scheme but with the need of more CPU-cycles.



@emph{Options}:
@itemize @minus
@item @strong{save_cpu_time}:  Use the memory-intensive procedure
@item @strong{save_ram_usage}:  Use the RAM-saving, CPU-intensive procedure
@end itemize

@c ----------------------------------
@item @strong{OpenBoundariesQMRMaxIter}@*
@vindex @code{OpenBoundariesQMRMaxIter}@*
@emph{Section}: Open Boundaries@*
@emph{Type}: integer@*
@emph{Default}: 100@*
@* Sets the maximum iteration number for the QMR linear solver in
 the Crank-Nicholson procedure for open boundaries.



@c ----------------------------------
@item @strong{OpenBoundariesQMRTol}@*
@vindex @code{OpenBoundariesQMRTol}@*
@emph{Section}: Open Boundaries@*
@emph{Type}: integer@*
@emph{Default}: 1e-12@*
@* Sets the convergence tolerance for the residue in the QMR linear solver
 in the Crank-Nicholson procedure.



@c ----------------------------------
@end itemize
@node Output,,,
@section Output
@c ----------------------------------

@itemize
@item @strong{DOSEnergyMax}@*
@vindex @code{DOSEnergyMax}@*
@emph{Section}: Output@*
@emph{Type}: float@*
@* Upper bound for the energy mesh of the DOS.
 The default is the highest eigenvalue, plus a quarter of the total range of eigenvalues.



@c ----------------------------------
@item @strong{DOSEnergyMin}@*
@vindex @code{DOSEnergyMin}@*
@emph{Section}: Output@*
@emph{Type}: float@*
@* Lower bound for the energy mesh of the DOS.
 The default is the lowest eigenvalue, minus a quarter of the total range of eigenvalues.



@c ----------------------------------
@item @strong{DOSEnergyPoints}@*
@vindex @code{DOSEnergyPoints}@*
@emph{Section}: Output@*
@emph{Type}: integer@*
@emph{Default}: 500@*
@* Determines how many energy points @t{Octopus} should use for
 the DOS energy grid.



@c ----------------------------------
@item @strong{DOSGamma}@*
@vindex @code{DOSGamma}@*
@emph{Section}: Output@*
@emph{Type}: float@*
@emph{Default}: 0.008 Ha@*
@* Determines the width of the Lorentzian which is used for the DOS sum.



@c ----------------------------------
@item @strong{ELFWithCurrentTerm}@*
@vindex @code{ELFWithCurrentTerm}@*
@emph{Section}: Output@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* The ELF, when calculated for complex wavefunctions, should contain
 a term dependent on the current. This term is properly calculated by
 default; however, for research purposes it may be useful not to add it.
 If this feature proves to be useless, this option should go away.



@c ----------------------------------
@item @strong{LocalMagneticMomentsSphereRadius}@*
@vindex @code{LocalMagneticMomentsSphereRadius}@*
@emph{Section}: Output@*
@emph{Type}: float@*
@* The local magnetic moments are calculated by integrating the
 magnetization density in spheres centered around each atom.
 This variable controls the radius of the spheres.
 The default is half the minimum distance between two atoms
 in the input coordinates.



@c ----------------------------------
@item @strong{Output}@*
@vindex @code{Output}@*
@emph{Section}: Output@*
@emph{Type}: flag@*
@emph{Default}: no@*
@* Specifies what to print. The output files go into the @t{static} directory, except when
 running a time-dependent simulation, when the directory @t{td.XXXXXXX} is used. For
 linear-response run modes, the derivatives of many quantities can be printed, as listed in
 the options below; the files will be printed in the directory
 for the run mode. Indices in the filename are labelled as follows:
 @t{sp} = spin, @t{k} = @emph{k}-point, @t{st} = state/band,
 There is no tag for directions, given as a letter. The perturbation direction is always
 the last direction for linear-response quantities, and a following +/- indicates the sign of the frequency.
 Example: @t{density + potential}


@emph{Options}:
@itemize @minus
@item @strong{el_pressure}:  Outputs electronic pressure. See Tao, Vignale, and Tokatly, @emph{Phys Rev Lett} @strong{100}, 206405 (2008).
@item @strong{xc_density}:  Outputs the XC density, which is the charge density that
 generates the XC potential. (This is @math{-1/4\pi} times
 the Laplacian of the XC potential). The files are called @t{nxc}.
@item @strong{ELF_basins}:  Outputs basins of attraction of the ELF. The output file is called
 @t{elf_rs_basins.info}. Only in 2D and 3D.
@item @strong{tpa}:  Outputs transition-potential approximation (TPA) matrix elements.
@item @strong{mmb}:  This flag turns on the output for model many-body calculations, for
 particles described in the @t{DescribeParticlesModelMB} block.
@item @strong{kinetic_energy_density}:  Outputs kinetic-energy density, defined as:

 @math{\tau_\sigma(\vec{r}) = \sum_{i=1}^{N_\sigma}
  \vert \nabla \phi_{i\sigma}(\vec{r}) \vert^2\,. }

 The index @math{\sigma} is the spin index for the spin-polarized case,
 or if you are using spinors. For spin-unpolarized calculations, you
 get the total kinetic-energy density. The previous expression assumes full
 or null occupations. If fractional occupation numbers, each term in the sum
 is weighted by the occupation. Also, if we are working with an infinite
 system, all @emph{k}-points are summed up, with their corresponding weights. The
 files will be called @t{tau-sp1} and @t{tau-sp2}, if the spin-resolved kinetic
 energy density is produced (runs in spin-polarized and spinors mode), or
 only @t{tau} if the run is in spin-unpolarized mode.
@item @strong{BerkeleyGW}:  Output for a run with BerkeleyGW (@t{www.berkeleygw.org}). See @t{Output::BerkeleyGW} for further specification.
@item @strong{geometry}:  Outputs file containing the coordinates of the atoms treated within quantum mechanics.
 If @t{OutputHow = xyz}, the file is called @t{geometry.xyz}; a
 file @t{crystal.xyz} is written with a supercell geometry if the system is periodic;
 if point charges were defined in the PDB file (see @t{PDBCoordinates}), they will be output
 in the file @t{geometry_classical.xyz}.
 If @t{OutputHow = xcrysden}, a file called @t{geometry.xsf} is written.
@item @strong{potential}:  Outputs Kohn-Sham potential, separated by parts. File names are @t{v0} for
 the local part, @t{vc} for the classical potential (if it exists), @t{vh} for the
 Hartree potential, and @t{vxc-} for the exchange-correlation potentials.
@item @strong{matrix_elements}:  Outputs a series of matrix elements of the Kohn-Sham states. What is output can
 be controlled by the @t{OutputMatrixElements} variable.
@item @strong{PES_wfs}:  Outputs the photoelectron wavefunctions. The file name is @t{pes_wfs-}
 plus the orbital number.
@item @strong{ELF_FS}:  Outputs electron localization function in Fourier space (experimental). The output file is called
 @t{elf_FS-}. Only in 2D and 3D.
@item @strong{forces}:  Outputs file @t{forces.xsf} containing structure and forces on the atoms as
 a vector associated with each atom, which can be visualized with XCrySDen.
@item @strong{mmb_wfs}:  Triggers the ModelMB wavefunctions to be output for each state
@item @strong{density}:  Outputs density. The output file is called @t{density-}, or @t{lr_density-} in linear response.
@item @strong{current}:  Outputs paramagnetic current density. The output file is called @t{current-}.
 For linear response, the filename is @t{lr_current-}.
@item @strong{delta_perturbation}:  Outputs the "kick", or time-delta perturbation applied to compute linear response in real time.
@item @strong{pol_density}:  Outputs dipole-moment density @t{dipole_density-}, or polarizability density @t{alpha_density-}
 in linear response. If @t{ResponseMethod = finite_differences}, the hyperpolarizability density
 @t{beta_density-} is also printed.
@item @strong{PES_density}:  Outputs the photolectron density. Output file is @t{pes_dens-} plus spin species if
 spin-polarized calculation is performed.
@item @strong{wfs}:  Outputs wavefunctions. Which wavefunctions are to be printed is specified
 by the variable @t{OutputWfsNumber} -- see below. The output file is called
 @t{wf-}, or @t{lr_wf-} in linear response.
@item @strong{Bader}:  Outputs Laplacian of the density which shows lone pairs, bonded charge concentrations
 and regions subject to electrophilic or nucleophilic attack.
 See RF Bader, @emph{Atoms in Molecules: A Quantum Theory} (Oxford Univ. Press, Oxford, 1990).
@item @strong{wfs_fourier}:  (Experimental) Outputs wavefunctions in Fourier space. This is
 only implemented for the ETSF file format output. The file will
 be called @t{static/wfs-pw-etsf.nc}.
@item @strong{mmb_den}:  triggers the ModeMB density or density matrix to be output for each state, and the particles
 speficied by the DensitytoCalc block. In the latter case, calculates, and outputs, the reduced density
 matrix. For the moment the trace is made over the second dimension, and
 the code is limited to 2D. The idea is to model @emph{N} particles in 1D as an
 @emph{N}-dimensional non-interacting problem, then to trace out @emph{N}-1 coordinates.
@item @strong{ELF}:  Outputs electron localization function (ELF). The output file is called @t{elf-},
 or @t{lr_elf-} in linear response, in which case the associated function D is also written,
 as @t{lr_elf_D-}. Only in 2D and 3D.
@item @strong{dos}:  Outputs density of states.
@item @strong{external_td_potential}:  Outputs the (scalar) time-dependent potential.
@item @strong{mesh_r}:  Outputs values of the coordinates over the grid. Files
 will be in the @t{exec/} directory.
@item @strong{PES}:  Outputs the time-dependent photoelectron spectrum.
@item @strong{wfs_sqmod}:  Outputs modulus squared of the wavefunctions.
 The output file is called @t{sqm-wf-}. For linear response, the filename is @t{sqm_lr_wf-}.
@end itemize

@c ----------------------------------
@item @strong{OutputBandsGnuplotMode}@*
@vindex @code{OutputBandsGnuplotMode}@*
@emph{Section}: Output@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* The band file will be written in Gnuplot-friendly format to @t{bands-gp.dat}
 (or @t{band-gp-is.dat} if spin-polarized).



@c ----------------------------------
@item @strong{OutputBandsGraceMode}@*
@vindex @code{OutputBandsGraceMode}@*
@emph{Section}: Output@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* The band file will be written in Grace-friendly format to @t{bands-grace.dat}
 (or @t{bands-grace-is.dat} if spin-polarized).



@c ----------------------------------
@item @strong{OutputDuringSCF}@*
@vindex @code{OutputDuringSCF}@*
@emph{Section}: Output@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If this variable is set to yes, during a ground-state run,
 @t{Octopus} output will be written after every self-consistent
 iteration to a directory called @t{scf.nnnn/} (with
 @t{nnnn} the iteration number).



@c ----------------------------------
@item @strong{OutputEvery}@*
@vindex @code{OutputEvery}@*
@emph{Section}: Output@*
@emph{Type}: integer@*
@emph{Default}: 50@*
@* The output is saved when the iteration number is a multiple of the
 @t{OutputEvery} variable. This works for the ground-state and
 time-dependent runs.



@c ----------------------------------
@item @strong{OutputHow}@*
@vindex @code{OutputHow}@*
@emph{Section}: Output@*
@emph{Type}: flag@*
@* Describes the format of the output files (see @t{Output}).
 Example: @t{axis_x + plane_x + dx}


@emph{Options}:
@itemize @minus
@item @strong{xcrysden}:  A format for printing structures and three-dimensional information, which can be visualized by
 the free open-source program XCrySDen (@t{http://www.xcrysden.org/}). The string
 @t{.xsf} is appended to previous file names. Note that lattice vectors and coordinates are as
 specified by @t{UnitsOutput}.
@item @strong{netcdf}:  Outputs in NetCDF (@t{http://www.unidata.ucar.edu/packages/netcdf/}) format. This file
 can then be read, for example, by OpenDX. The string @t{.ncdf} is appended to previous file names.
 Requires the NetCDF library.
@item @strong{cube}:  Generates output in the cube file format (@t{http://local.wasp.uwa.edu.au/~pbourke/dataformats/cube/})
@item @strong{binary}:  Plain binary, new format.
@item @strong{plane_y}:  A plane slice at @emph{y} = 0 is printed. The string @t{.y=0} is appended
 to previous file names.
@item @strong{axis_x}:  The values of the function on the @emph{x} axis are printed. The string @t{.y=0,z=0} is appended
 to previous file names.
@item @strong{matlab}:  In combination with @t{plane_x}, @t{plane_y} and
 @t{plane_z}, this option produces output files which are
 suitable for 2D Matlab functions like @t{mesh()},
 @t{surf()}, or @t{waterfall()}. To load these files
 into Matlab you can use, @emph{e.g.}
@t{
   >> density = load('static/density-1.x=0.matlab.abs');
   >> mesh(density);
}
@item @strong{axis_y}:  The values of the function on the @emph{y} axis are printed. The string @t{.x=0,z=0} is appended
 to previous file names.
@item @strong{etsf}:  ETSF file format (@t{http://www.etsf.eu/resources/software/standardization_project}).
 Requires the ETSF_IO library.
@item @strong{plane_z}:  A plane slice at @emph{z} = 0 is printed. The string @t{.z=0} is appended to
 previous file names.
@item @strong{meshgrid}:  Outputs in Matlab mode the internal mesh in a format similar to
@t{
   >> [x,y] = meshgrid(-2:.2:2,-1:.15:1)
}
 The @emph{x} meshgrid is contained in a file @t{*.meshgrid.x} and the @emph{y}-grid can be found in
 @t{*.meshgrid.y}.
@item @strong{axis_z}:  The values of the function on the @emph{z} axis are printed. The string @t{.x=0,y=0} is appended
 to previous file names.
@item @strong{mesh_index}:  Generates output files of a given quantity (density, wavefunctions, ...) which include
 the internal numbering of mesh points. Since this mode produces large datafiles this is only
 useful for small meshes and debugging purposes.
 The output can also be used to display the mesh directly. A Gnuplot script for mesh vizualization
 can be found under @t{PREFIX/share/octopus/util/display_mesh_index.gp}.
@item @strong{dx}:  For printing three-dimensional information, the open-source program
 visualization tool OpenDX (@t{http://www.opendx.org/}) can be used. The string
 @t{.dx} is appended to previous file names.
@item @strong{xyz}:  Geometry will be output in XYZ format. Does not affect other outputs.
@item @strong{boundary_points}:  This option includes the output of the mesh enlargement. Default is without.
@item @strong{plane_x}:  A plane slice at @emph{x} = 0 is printed. The string @t{.x=0} is appended
 to previous file names.
@end itemize

@c ----------------------------------
@item @strong{OutputMEMultipoles}@*
@vindex @code{OutputMEMultipoles}@*
@emph{Section}: Output@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* This variable decides which multipole moments
 are printed out: @emph{e.g.}, if 1, then the
 program will print three files, @t{ks_multipoles.x} (@t{x}=1,2,3), containing
 respectively the (1,-1), (1,0) and (1,1) multipole matrix elements
 between Kohn-Sham states.



@c ----------------------------------
@item @strong{OutputMatrixElements}@*
@vindex @code{OutputMatrixElements}@*
@emph{Section}: Output@*
@emph{Type}: flag@*
@emph{Default}: no@*
@* Specifies what matrix elements to print.
 The output files go into the @t{static} directory, except when
 running a time-dependent simulation, when the directory @t{td.XXXXXXX} is used.
 Example: "momentum + ks_multipoles"


@emph{Options}:
@itemize @minus
@item @strong{ks_multipoles}:  TODO
@item @strong{momentum}:  TODO
@item @strong{ang_momentum}:  TODO
@item @strong{one_body}:  @math{<i|T + V_{ext}|j>}
@item @strong{two_body}:  @math{<ij| 1/|r_1-r_2| |kl>}
@end itemize

@c ----------------------------------
@item @strong{OutputWfsNumber}@*
@vindex @code{OutputWfsNumber}@*
@emph{Section}: Output@*
@emph{Type}: string@*
@emph{Default}: all states@*
@* Which wavefunctions to print, in list form: @emph{i.e.}, "1-5" to print the first
 five states, "2,3" to print the second and the third state, etc.
 If more states are specified than available, extra ones will be ignored.



@c ----------------------------------
@end itemize
@node BerkeleyGW,,,
@subsection BerkeleyGW
@c ----------------------------------

@itemize
@item @strong{BerkeleyGW_CalcExchange}@*
@vindex @code{BerkeleyGW_CalcExchange}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Whether to calculate exchange matrix elements to be written in @t{x.dat}.
 These will be calculated anyway by BerkeleyGW @t{Sigma}, so this is useful
 mainly for comparison and testing.



@c ----------------------------------
@item @strong{BerkeleyGW_Complex}@*
@vindex @code{BerkeleyGW_Complex}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Even when wavefunctions, density, and XC potential could be real in reciprocal space,
 they will be output as complex.



@c ----------------------------------
@item @strong{BerkeleyGW_NumberBands}@*
@vindex @code{BerkeleyGW_NumberBands}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: integer@*
@emph{Default}: all states@*
@* Wavefunctions for bands up to this number will be output.



@c ----------------------------------
@item @strong{BerkeleyGW_Vxc_diag_nmax}@*
@vindex @code{BerkeleyGW_Vxc_diag_nmax}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: integer@*
@emph{Default}: nst@*
@* Highest band for which to write diagonal exchange-correlation matrix elements.



@c ----------------------------------
@item @strong{BerkeleyGW_Vxc_diag_nmin}@*
@vindex @code{BerkeleyGW_Vxc_diag_nmin}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Lowest band for which to write diagonal exchange-correlation matrix elements.



@c ----------------------------------
@item @strong{BerkeleyGW_Vxc_offdiag_nmax}@*
@vindex @code{BerkeleyGW_Vxc_offdiag_nmax}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: integer@*
@emph{Default}: nst@*
@* Highest band for which to write off-diagonal exchange-correlation matrix elements.
 If < 1, off-diagonals will be skipped.



@c ----------------------------------
@item @strong{BerkeleyGW_Vxc_offdiag_nmin}@*
@vindex @code{BerkeleyGW_Vxc_offdiag_nmin}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Lowest band for which to write off-diagonal exchange-correlation matrix elements.
 If < 1, off-diagonals will be skipped.



@c ----------------------------------
@item @strong{BerkeleyGW_WFN_filename}@*
@vindex @code{BerkeleyGW_WFN_filename}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: string@*
@emph{Default}: WFN@*
@* Filename for the wavefunctions.



@c ----------------------------------
@end itemize
@node SCF,,,
@section SCF
@c ----------------------------------

@itemize
@item @strong{GuessMagnetDensity}@*
@vindex @code{GuessMagnetDensity}@*
@emph{Section}: SCF@*
@emph{Type}: integer@*
@emph{Default}: ferromagnetic@*
@* The guess density for the SCF cycle is just the sum of all the atomic densities.
 When performing spin-polarized or non-collinear-spin calculations this option sets
 the guess magnetization density.

 For anti-ferromagnetic configurations, the @t{user_defined} option should be used.

 Note that if the @t{paramagnetic} option is used, the final ground state will also be
 paramagnetic, but the same is not true for the other options.


@emph{Options}:
@itemize @minus
@item @strong{paramagnetic}:  Magnetization density is zero.
@item @strong{ferromagnetic}:  Magnetization density is the sum of the atomic magnetization densities.
@item @strong{random}:  Each atomic magnetization density is randomly rotated.
@item @strong{user_defined}:  The atomic magnetization densities are rotated so that the magnetization
 vector has the same direction as a vector provided by the user. In this case,
 the @t{AtomsMagnetDirection} block has to be set.
@end itemize

@c ----------------------------------
@item @strong{LCAOStart}@*
@vindex @code{LCAOStart}@*
@emph{Section}: SCF@*
@emph{Type}: integer@*
@* Before starting a SCF calculation, @t{Octopus} can perform
 a LCAO calculation. These can provide @t{Octopus} with a good set
 of initial wavefunctions and with a new guess for the density.
 (Up to the current version, only a minimal basis set is used.)
 The default is @t{lcao_full} unless all species are user-defined, in which case
 the default is @t{lcao_none}.


@emph{Options}:
@itemize @minus
@item @strong{lcao_none}:  Do not perform a LCAO calculation before the SCF cycle. Instead use random wavefunctions.
@item @strong{lcao_states}:  Do a LCAO calculation before the SCF cycle and use the resulting wavefunctions as
 initial wavefunctions without changing the guess density.
 This will speed up the convergence of the eigensolver during the first SCF iterations.
@item @strong{lcao_full}:  Do a LCAO calculation before the SCF cycle and use the LCAO wavefunctions to build a new
 guess density and a new KS potential.
 Using the LCAO density as a new guess density may improve the convergence, but can
 also slow it down or yield wrong results (especially for spin-polarized calculations).
@end itemize

@c ----------------------------------
@item @strong{SCFCalculateDipole}@*
@vindex @code{SCFCalculateDipole}@*
@emph{Section}: SCF@*
@emph{Type}: logical@*
@* This variable controls whether the dipole is calculated at the
 end of a self-consistent iteration. For finite systems the
 default is yes. For periodic systems the default is no, unless
 an electric field is being applied in a periodic direction.
 The single-point Berry`s phase approximation is used for
 periodic directions.



@c ----------------------------------
@item @strong{SCFCalculateForces}@*
@vindex @code{SCFCalculateForces}@*
@emph{Section}: SCF@*
@emph{Type}: logical@*
@* This variable controls whether the forces on the ions are
 calculated at the end of a self-consistent iteration. The
 default is yes, unless the system only has user-defined
 species.



@c ----------------------------------
@item @strong{SCFinLCAO}@*
@vindex @code{SCFinLCAO}@*
@emph{Section}: SCF@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* Performs the SCF cycle with the calculation restricted to the LCAO subspace.
 This may be useful for systems with convergence problems (first do a
 calculation within the LCAO subspace, then restart from that point for
 an unrestricted calculation).



@c ----------------------------------
@end itemize
@node Convergence,,,
@subsection Convergence
@c ----------------------------------

@itemize
@item @strong{ConvAbsDens}@*
@vindex @code{ConvAbsDens}@*
@emph{Section}: SCF::Convergence@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Absolute convergence of the density:

 @math{\epsilon = \int {\rm d}^3r \vert \rho^{out}(\bf r) -\rho^{inp}(\bf r) \vert}.

 A zero value (the default) means do not use this criterion.



@c ----------------------------------
@item @strong{ConvAbsEv}@*
@vindex @code{ConvAbsEv}@*
@emph{Section}: SCF::Convergence@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Absolute convergence of the sum of the eigenvalues:

 @math{ \epsilon = \vert \sum_{j=1}^{N_{occ}} \epsilon_j^{out} - \sum_{j=1}^{N_{occ}} \epsilon_j^{inp} \vert }

 A zero value (the default) means do not use this criterion.



@c ----------------------------------
@item @strong{ConvForce}@*
@vindex @code{ConvForce}@*
@emph{Section}: SCF::Convergence@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Absolute convergence of the forces: maximum variation of any
 component of the ionic forces in consecutive iterations.  A
 zero value means do not use this criterion. The default is
 zero, except for geometry optimization, which sets a default of
 1e-8.



@c ----------------------------------
@item @strong{ConvRelDens}@*
@vindex @code{ConvRelDens}@*
@emph{Section}: SCF::Convergence@*
@emph{Type}: float@*
@emph{Default}: 1e-5@*
@* Relative convergence of the density:

 @math{\epsilon = {1\over N} ConvAbsDens}.

 @emph{N} is the total number of electrons in the problem.  A
 zero value means do not use this criterion.



@c ----------------------------------
@item @strong{ConvRelEv}@*
@vindex @code{ConvRelEv}@*
@emph{Section}: SCF::Convergence@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Relative convergence of the sum of the eigenvalues:

 @math{\epsilon = \vert \sum_{j=1}^{N_{occ}} ( \epsilon_j^{out} -  \epsilon_j^{inp} ) \vert
 \over \vert \sum_{j=1}^{N_{occ}} \epsilon_j^{out} \vert }




@c ----------------------------------
@item @strong{MaximumIter}@*
@vindex @code{MaximumIter}@*
@emph{Section}: SCF::Convergence@*
@emph{Type}: integer@*
@emph{Default}: 200@*
@* Maximum number of SCF iterations. The code will stop even if convergence
 has not been achieved. -1 means unlimited.



@c ----------------------------------
@item @strong{MaximumIterBerry}@*
@vindex @code{MaximumIterBerry}@*
@emph{Section}: SCF::Convergence@*
@emph{Type}: integer@*
@emph{Default}: 10@*
@* Maximum number of iterations for the Berry potential, within each SCF iteration.
 Only applies if a @t{StaticElectricField} is applied in a periodic direction.
 The code will move on to the next SCF iteration even if convergence
 has not been achieved. -1 means unlimited.



@c ----------------------------------
@end itemize
@node EigenSolver,,,
@subsection EigenSolver
@c ----------------------------------

@itemize
@item @strong{EigenSolverArnoldiVectors}@*
@vindex @code{EigenSolverArnoldiVectors}@*
@emph{Section}: SCF::EigenSolver@*
@emph{Type}: integer@*
@emph{Default}: 20@*
@* This indicates how many Arnoldi vectors are generated
 It must satisfy EigenSolverArnoldiVectors - Number Of Eigenvectors >= 2.
 See the ARPACK documentation for more details. It will default to
 twice the number of eigenvectors (which is the number of states)



@c ----------------------------------
@end itemize
@node Eigensolver,,,
@subsection Eigensolver
@c ----------------------------------

@itemize
@item @strong{Eigensolver}@*
@vindex @code{Eigensolver}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: integer@*
@* Which eigensolver to use to obtain the lowest eigenvalues and
 eigenfunctions of the Kohn-Sham Hamiltonian. The default is
 conjugate gradients (@t{cg}); when parallelization in states is
 enabled, the default is @t{lobpcg}.


@emph{Options}:
@itemize @minus
@item @strong{rmmdiis}:  Residual minimization scheme, direct inversion in the
 iterative subspace eigensolver, based on the implementation of
 Kresse and Furthmller [@emph{Phys. Rev. B} @strong{54}, 11169
 (1996)]. This eigensolver requires almost no orthogonalization
 so it can be considerably faster than the other options for
 large systems; however it might suffer stability problems. To
 improve its performance a large number of @t{ExtraStates}
 are required (around 10-20% of the number of occupied states).
@item @strong{plan}:  Preconditioned Lanczos scheme.
@item @strong{arpack}:  Implicitly Restarted Arnoldi Method. Requires the ARPACK package.
 method.
@item @strong{cg}:  Conjugate-gradients algorithm.
@item @strong{cg_new}:  An alternative conjugate-gradients eigensolver, faster for
 larger systems but less mature.
@item @strong{multigrid}:  (Experimental) Multigrid eigensolver.
@item @strong{lobpcg}:  (Experimental) Locally optimal block-preconditioned
 conjugate-gradient algorithm. Ref: A. Knyazev, Toward the
 Optimal Preconditioned Eigensolver: Locally Optimal Block
 Preconditioned Conjugate Gradient Method, @emph{SIAM Journal on
 Scientific Computing}, 23(2):517-541, 2001.
@item @strong{evolution}:  Propagation in imaginary time. WARNING: Sometimes it misbehaves. Use with
 caution.
@end itemize

@c ----------------------------------
@item @strong{EigensolverImaginaryTime}@*
@vindex @code{EigensolverImaginaryTime}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: float@*
@emph{Default}: 10.0@*
@* The imaginary-time step that is used in the imaginary-time evolution
 method (@t{Eigensolver = evolution}) to obtain the lowest eigenvalues/eigenvectors.
 It must satisfy @t{EigensolverImaginaryTime > 0}.



@c ----------------------------------
@item @strong{EigensolverMaxIter}@*
@vindex @code{EigensolverMaxIter}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: integer@*
@* Determines the maximum number of iterations that the
 eigensolver will perform if the desired tolerance is not
 achieved. The default is 25 iterations for all eigensolvers
 except for @t{rmdiis}, which performs only 3 iterations (only
 increase it if you know what you are doing).



@c ----------------------------------
@item @strong{EigensolverMinimizationIter}@*
@vindex @code{EigensolverMinimizationIter}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: integer@*
@emph{Default}: 5@*
@* During the first iterations, the RMMDIIS eigensolver requires
 some steepest-descent minimizations to improve
 convergence. This variable determines the number of those
 minimizations. The default is 5.



@c ----------------------------------
@item @strong{EigensolverSubspaceDiag}@*
@vindex @code{EigensolverSubspaceDiag}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* Allows you to turn off subspace diagonalization during the diagonalization of
 the Hamiltonian. Subspace diagonalization sometimes creates problems when restarting
 unoccupied-states calculations with a larger number of unoccupied states.



@c ----------------------------------
@item @strong{EigensolverTolerance}@*
@vindex @code{EigensolverTolerance}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: float@*
@emph{Default}: 1.0e-6@*
@* This is the tolerance for the eigenvectors. The default is 1e-6.



@c ----------------------------------
@item @strong{Preconditioner}@*
@vindex @code{Preconditioner}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: integer@*
@emph{Default}: filter@*
@* Which preconditioner to use in order to solve the Kohn-Sham equations or
 the linear-response equations. May apply prefix of linear-response (@emph{e.g.}
 @t{EM}, @t{KdotP}, @t{VM}) to differentiate from choice for ground state.


@emph{Options}:
@itemize @minus
@item @strong{no}:  Do not apply preconditioner.
@item @strong{pre_filter}:  Filter preconditioner.
@item @strong{pre_jacobi}:  Jacobi preconditioner. Only the local part of the pseudopotential is used.
 Not very helpful.
@item @strong{pre_poisson}:  Uses the full Laplacian as preconditioner. The inverse is calculated through
 the solution of the Poisson equation. This is, of course, very slow.
@item @strong{pre_multigrid}:  Multigrid preconditioner.
@end itemize

@c ----------------------------------
@item @strong{SubspaceDiagonalization}@*
@vindex @code{SubspaceDiagonalization}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: integer@*
@emph{Default}: standard@*
@* Selects the method to perform subspace diagonalization. The
 default is @t{standard}, unless states parallelization is used,
 when the default is @t{scalapack}.


@emph{Options}:
@itemize @minus
@item @strong{standard}:  The standard routine. Can be used with domain parallelization but not
 state parallelization.
@item @strong{old}:  Old routine, compatible with states parallelization.
@item @strong{scalapack}:  State-parallelized version using ScaLAPACK. (Requires that
 Octopus was compiled with ScaLAPACK support.)
@end itemize

@c ----------------------------------
@end itemize
@node LCAO,,,
@subsection LCAO
@c ----------------------------------

@itemize
@item @strong{LCAOAlternative}@*
@vindex @code{LCAOAlternative}@*
@emph{Section}: SCF::LCAO@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* If this variable is set, the LCAO procedure will use an
 alternative (and experimental) implementation. It is faster for
 large systems and parallel in states.



@c ----------------------------------
@item @strong{LCAODiagTol}@*
@vindex @code{LCAODiagTol}@*
@emph{Section}: SCF::LCAO@*
@emph{Type}: float@*
@emph{Default}: 1e-10@*
@* The tolerance for the diagonalization of the LCAO Hamiltonian. The default is 1e-10.



@c ----------------------------------
@item @strong{LCAODimension}@*
@vindex @code{LCAODimension}@*
@emph{Section}: SCF::LCAO@*
@emph{Type}: integer@*
@* Before starting the SCF cycle, an initial LCAO calculation can be performed
 in order to obtain reasonable initial guesses for spin-orbitals and densities.
 For this purpose, the code calculates a number of atomic orbitals -- this
 number depends on the given species. The default dimension for the LCAO basis
 set will be the sum of all these numbers, unless this dimension is larger than
 twice the number of required orbitals for the full calculation.

 This dimension however can be changed by making use of this
 variable. Note that @t{LCAODimension} cannot be smaller than the
 number of orbitals needed in the full calculation -- if
 @t{LCAODimension} is smaller, it will be silently increased to meet
 this requirement. In the same way, if @t{LCAODimension} is larger
 than the available number of atomic orbitals, it will be
 reduced. If you want to use the largest possible number, set
 @t{LCAODimension} to a negative number.



@c ----------------------------------
@item @strong{LCAOExtraOrbitals}@*
@vindex @code{LCAOExtraOrbitals}@*
@emph{Section}: SCF::LCAO@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* (experimental) If this variable is set to yes, the LCAO
 procedure will add an extra set of numerical orbitals (by
 using the derivative of the radial part of the original
 orbitals).



@c ----------------------------------
@item @strong{LCAOKeepOrbitals}@*
@vindex @code{LCAOKeepOrbitals}@*
@emph{Section}: SCF::LCAO@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* If set to yes (the default) Octopus keeps atomic orbitals in
 memory during the LCAO procedure. If set to no, the orbitals
 are generated each time that they are needed, increasing
 computational time but saving memory.

 When set to yes, Octopus prints the amount of memory per node
 that is required to store the orbitals.




@c ----------------------------------
@end itemize
@node Mixing,,,
@subsection Mixing
@c ----------------------------------

@itemize
@item @strong{MixField}@*
@vindex @code{MixField}@*
@emph{Section}: SCF::Mixing@*
@emph{Type}: integer@*
@emph{Default}: density@*
@* Selects what should be mixed during the SCF cycle.  Note that
 currently the exact-exchange part of hybrid functionals is not
 mixed at all, which would require wavefunction-mixing, not yet
 implemented. This may lead to instabilities in the SCF cycle,
 so starting from a converged LDA/GGA calculation is recommended
 for hybrid functionals. The default depends on the @t{TheoryLevel}
 and the exchange-correlation potential used.


@emph{Options}:
@itemize @minus
@item @strong{none}:  No mixing is done. This is the default for independent
 particles.
@item @strong{potential}:  The Kohn-Sham potential is mixed. This is the default for OEP
 or MGGA calculations, or if @t{StaticElectricField} is applied in
 a periodic direction.
@item @strong{density}:  Mix the density. This is the default for other cases, including
 LDA/GGA calculations.
@end itemize

@c ----------------------------------
@item @strong{MixNumberSteps}@*
@vindex @code{MixNumberSteps}@*
@emph{Section}: SCF::Mixing@*
@emph{Type}: integer@*
@emph{Default}: 3@*
@* In the Broyden and GR-Pulay schemes, the new input density or potential is constructed
 from the values of the densities/potentials of a given number of previous iterations.
 This number is set by this variable. Must be greater than 1.



@c ----------------------------------
@item @strong{Mixing}@*
@vindex @code{Mixing}@*
@emph{Section}: SCF::Mixing@*
@emph{Type}: float@*
@emph{Default}: 0.3@*
@* Both the linear and the Broyden scheme depend on a "mixing parameter", set by this variable.  Must be 0 < @t{Mixing} <= 1.



@c ----------------------------------
@item @strong{TypeOfMixing}@*
@vindex @code{TypeOfMixing}@*
@emph{Section}: SCF::Mixing@*
@emph{Type}: integer@*
@emph{Default}: broyden@*
@* The scheme used to produce, at each iteration in the self-consistent cycle
 that attempts to solve the Kohn-Sham equations, the input density from the value
 of the input and output densities of previous iterations.


@emph{Options}:
@itemize @minus
@item @strong{linear}:  Simple linear mixing.
@item @strong{gr_pulay}:  "Guaranteed-reduction" Pulay scheme [D. R. Bowler and M. J. Gillan, @emph{Chem. Phys.
 Lett.} @strong{325}, 473 (2000)].
@item @strong{broyden}:  Broyden scheme [C. G Broyden, @emph{Math. Comp.} @strong{19}, 577 (1965);
 D. D. Johnson, @emph{Phys. Rev. B} @strong{38}, 12807 (1988)].
@end itemize

@c ----------------------------------
@end itemize
@node States,,,
@section States
@c ----------------------------------

@itemize
@item @strong{CurrentInTau}@*
@vindex @code{CurrentInTau}@*
@emph{Section}: States@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* If true, a term including the (paramagnetic or total) current is included in the calculation of the kinetic-energy density.



@c ----------------------------------
@item @strong{CurrentThroughPlane}@*
@vindex @code{CurrentThroughPlane}@*
@emph{Section}: States@*
@emph{Type}: block@*
@* At the end of the ground-state calculation, the code can calculate
 the steady-state current in the ground state
 traversing a user-defined portion of a plane, as specified by this block.
 In the format below, @t{origin} is a point in the plane.
 @t{u} and @t{v} are the (dimensionless) lattice vectors defining the plane;
 they will be normalized by the code. @t{spacing} is the fineness of the mesh
 on the plane. Integers @t{nu} and @t{mu} are the length and
 width of the portion of the plane, in units of @t{spacing}.
 Thus, the grid points included in the plane are
 @t{x_ij = origin + i*spacing*u + j*spacing*v},
 for @t{nu <= i <= mu } and @t{nv <= j <= mv}.
 Analogously, in the 2D case, the current flow is calculated through a line;
 in the 1D case, the current flow is calculated through a point.

 Example (3D):

 @t{%CurrentThroughPlane
 @*@ @  0.0 | 0.0 | 0.0  # origin
 @*@ @  0.0 | 1.0 | 0.0  # u
 @*@ @  0.0 | 0.0 | 1.0  # v
 @*@ @  0.2              # spacing
 @*@ @  0 | 50           # nu | mu
 @*@ @  -50 | 50         # nv | mv
 @*%}

 Example (2D):

 @t{%CurrentThroughPlane
 @*@ @  0.0 | 0.0        # origin
 @*@ @  1.0 | 0.0        # u
 @*@ @  0.2              # spacing
 @*@ @  0 | 50           # nu | mu
 @*%}

 Example (1D):

 @t{%CurrentThroughPlane
 @*@ @  0.0              # origin
 @*%}




@c ----------------------------------
@item @strong{DegeneracyThreshold}@*
@vindex @code{DegeneracyThreshold}@*
@emph{Section}: States@*
@emph{Type}: float@*
@emph{Default}: 1e-5@*
@* A state j with energy E_j will be considered degenerate with a state
 with energy E_i, if  E_i - threshold < E_j < E_i + threshold.



@c ----------------------------------
@item @strong{DensitytoCalc}@*
@vindex @code{DensitytoCalc}@*
@emph{Section}: States@*
@emph{Type}: block@*
@* choice of which particle density (event. matrices) will be calculated and output, in the
  modelmb particles scheme

 @t{%DensitytoCalc
 @*@ @  proton   | 1 | 10
 @*@ @  electron | 2 | 15
 @*%}

 would ask octopus to calculate the density matrix corresponding to the 1st
 particle (whose coordinates correspond to dimensions 1 to ndim_modelmb),
 which is an proton, then that corresponding to the 2nd particle
 (electron with dimensions ndim_modelmb+1 to 2*ndim_modelmb), printing
 10 natural orbitals for the first and 15 for the second.

 @t{%DensitytoCalc
 @*@ @  proton   | 1 | -1
 @*@ @  electron | 2 | -1
 @*%}

 would ask octopus to print out just the densities for particles 1 and 2
 without any density matrix output.




@c ----------------------------------
@item @strong{DescribeParticlesModelmb}@*
@vindex @code{DescribeParticlesModelmb}@*
@emph{Section}: States@*
@emph{Type}: block@*
@* Characterization of different modelmb particles in gr%mesh%sb%dim dimensional space.

 @t{%DescribeParticlesModelmb
 @*@ @  proton   | 1 | 1800. | 1. | fermion
 @*@ @  proton   | 1 | 1800. | 1. | fermion
 @*@ @  electron | 2 | 1.    | 1. | fermion
 @*%}

 would tell @t{Octopus} that there are presently 3 particles, called proton, proton,
 and electron, with types 1, 1, and 2, and corresponding masses and charges.
 All particles should be fermions, and this can be later enforced on the spatial
 part of the wavefunctions.
 The label and charge are presently only for informational purposes and
 are not checked or used in @t{Octopus}. The interaction has to take the
 actual charge into account.



@emph{Options}:
@itemize @minus
@item @strong{fermion}:   Particle is a fermion.
@item @strong{boson}:   Particle is a boson.
@item @strong{anyon}:   Particle is neither fermion nor boson.
@end itemize

@c ----------------------------------
@item @strong{ExcessCharge}@*
@vindex @code{ExcessCharge}@*
@emph{Section}: States@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* The net charge of the system. A negative value means that we are adding
 electrons, while a positive value means we are taking electrons
 from the system.



@c ----------------------------------
@item @strong{ExtraStates}@*
@vindex @code{ExtraStates}@*
@emph{Section}: States@*
@emph{Type}: integer@*
@* The number of states is in principle calculated considering the minimum
 numbers of states necessary to hold the electrons present in the system.
 The number of electrons is
 in turn calculated considering the nature of the species supplied in the
 @t{Species} block, and the value of the @t{ExcessCharge} variable.
 However, one may command @t{Octopus} to use more states, which is necessary if one wants to
 use fractional occupational numbers, either fixed from the beginning through
 the @t{Occupations} block or by prescribing
 an electronic temperature with @t{Smearing}.

 Note that this number is unrelated to @t{CalculationMode == unocc}.
 @t{ExtraStates} is used for a self-consistent calculation and
 the usual convergence criteria on the density do not take into account the
 eigenvalues, whereas @t{unocc} is a non-self-consistent calculation,
 and explicitly considers the eigenvalues of the unoccupied states as the
 convergence criteria.



@c ----------------------------------
@item @strong{FrozenSystems}@*
@vindex @code{FrozenSystems}@*
@emph{Section}: States@*
@emph{Type}: block@*
@*


@c ----------------------------------
@item @strong{InitialSpins}@*
@vindex @code{InitialSpins}@*
@emph{Section}: States@*
@emph{Type}: block@*
@* The spin character of the initial random guesses for the spinors can
 be fixed by making use of this block. Note that this will not "fix" the
 the spins during the calculation (this cannot be done in spinors mode, in
 being able to change the spins is why the spinors mode exists in the first
 place).

 This block is meaningless and ignored if the run is not in spinors mode
 (@t{SpinComponents = spinors}).

 The structure of the block is very simple: each column contains the desired
 <@emph{S_x}>, <@emph{S_y}>, <@emph{S_z}> for each spinor.
 If the calculation is for a periodic system
 and there is more than one @emph{k}-point, the spins of all the @emph{k}-points are
 the same.

 For example, if we have two spinors, and we want one in the @emph{Sx} "down" state,
 and another one in the @emph{Sx} "up" state:

 @t{%InitialSpins
 @*@ @   0.5 | 0.0 | 0.0
 @*@ @  -0.5 | 0.0 | 0.0
 @*%}

 WARNING: if the calculation is for a system described by pseudopotentials (as
 opposed to user-defined potentials or model systems), this option is
 meaningless since the random spinors are overwritten by the atomic orbitals.

 There are a couple of physical constraints that have to be fulfilled:

 (A) | <@emph{S_i}> | <= 1/2

 (B) <@emph{S_x}>^2 + <@emph{S_y}>^2 + <@emph{S_z}>^2 = 1/4




@c ----------------------------------
@item @strong{MomentumTransfer}@*
@vindex @code{MomentumTransfer}@*
@emph{Section}: States@*
@emph{Type}: block@*
@* Momentum-transfer vector @emph{q} to be used when calculating matrix elements
 <f|exp(iq.r)|i>. This enables the calculation of the dynamical structure factor,
 which is closely related to generalized oscillator strengths.
 If the vector is not given, but TPA output is requested (@t{Output = TPA}),
 only the oscillator strengths are written in the output file.
 For example, to use @emph{q} = (0.1, 0.2, 0.3), set

 @t{%MomentumTransfer
 @*@ @  0.1 | 0.2 | 0.3
 @*%}



@c ----------------------------------
@item @strong{NDimModelmb}@*
@vindex @code{NDimModelmb}@*
@emph{Section}: States@*
@emph{Type}: integer@*
@emph{Default}: -1@*
@* Number of dimensions for modelmb space.
 Full Ndim = @t{NDimModelmb}*@t{NParticleModelmb}




@c ----------------------------------
@item @strong{NParticleModelmb}@*
@vindex @code{NParticleModelmb}@*
@emph{Section}: States@*
@emph{Type}: integer@*
@* Number of particles in modelmb space.
 Full Ndim = @t{NDimModelmb}*@t{NParticleModelmb}



@c ----------------------------------
@item @strong{NTypeParticleModelmb}@*
@vindex @code{NTypeParticleModelmb}@*
@emph{Section}: States@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Number of different types of particles in modelmb space.



@c ----------------------------------
@item @strong{Occupations}@*
@vindex @code{Occupations}@*
@emph{Section}: States@*
@emph{Type}: block@*
@* The occupation numbers of the orbitals can be fixed through the use of this
 variable. For example:

 @t{%Occupations
 @*@ @ 2.0 | 2.0 | 2.0 | 2.0 | 2.0
 @*%}

 would fix the occupations of the five states to @emph{2.0}. There can be
 at most as many columns as states in the calculation. If there are fewer columns
 than states, then the code will assume that the user is indicating the occupations
 of the uppermost states, assigning maximum occupation (i.e. 2 for spin-unpolarized
 calculations, 1 otherwise) to the lower states. If @t{SpinComponents == polarized}
 this block should contain two lines, one for each spin channel.
 This variable is very useful when dealing with highly symmetric small systems
 (like an open-shell atom), for it allows us to fix the occupation numbers
 of degenerate states in order to help @t{octopus} to converge. This is to
 be used in conjuction with @t{ExtraStates}. For example, to calculate the
 carbon atom, one would do:

 @t{ExtraStates = 2
 @*%Occupations
 @*@ @ 2 | 2/3 | 2/3 | 2/3
 @*%}

 If you want the calculation to be spin-polarized (which makes more sense), you could do:

 @t{ExtraStates = 2
 @*%Occupations
 @*@ @  2/3 | 2/3 | 2/3
 @*@ @  0   |   0 |   0
 @*%}

 Note that in this case the first state is absent, the code will calculate four states
 (two because there are four electrons, plus two because @t{ExtraStates} = 2), and since
 it finds only three columns, it will occupy the first state with one electron for each
 of the spin options.

 If the sum of occupations is not equal to the total charge set by @t{ExcessCharge},
 an error message is printed.
 If }FromScratch = no} and @t{RestartFixedOccupations = yes},
 this block will be ignored.



@c ----------------------------------
@item @strong{OnlyUserDefinedInitialStates}@*
@vindex @code{OnlyUserDefinedInitialStates}@*
@emph{Section}: States@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If true, then only user-defined states from the block @t{UserDefinedStates}
 will be used as initial states for a time-propagation. No attempt is made
 to load ground-state orbitals from a previous ground-state run.



@c ----------------------------------
@item @strong{RestartFixedOccupations}@*
@vindex @code{RestartFixedOccupations}@*
@emph{Section}: States@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* Setting this variable will make the restart proceed as
 if the occupations from the previous calculation had been set via the @t{Occupations} block,
 @emph{i.e.} fixed. Otherwise, occupations will be determined by smearing.



@c ----------------------------------
@item @strong{RestartReorderOccs}@*
@vindex @code{RestartReorderOccs}@*
@emph{Section}: States@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* Consider doing a ground-state calculation, and then restarting with new occupations set
 with the @t{Occupations} block, in an attempt to populate the orbitals of the original
 calculation. However, the eigenvalues may reorder as the density changes, in which case the
 occupations will now be referring to different orbitals. Setting this variable to yes will
 try to solve this issue when the restart data is being read, by reordering the occupations
 according to the order of the expectation values of the restart wavefunctions.



@c ----------------------------------
@item @strong{Smearing}@*
@vindex @code{Smearing}@*
@emph{Section}: States@*
@emph{Type}: float@*
@emph{Default}: 0.1 eV@*
@* If @t{Occupations} is not set, @t{Smearing} is the
 smearing width used in the @t{SmearingFunction} to distribute the electrons
 among the existing states.



@c ----------------------------------
@item @strong{SmearingFunction}@*
@vindex @code{SmearingFunction}@*
@emph{Section}: States@*
@emph{Type}: integer@*
@emph{Default}: semiconducting@*
@* This is the function used to smear the electronic occupations.
 It is ignored if the @t{Occupations} block is set.


@emph{Options}:
@itemize @minus
@item @strong{semiconducting}:  Semiconducting occupations, @emph{i.e.} the lowest lying states are occupied
 until no more electrons are left.
@item @strong{fermi_dirac}:  Simple Fermi-Dirac distribution. In this case, @t{Smearing} has
 the meaning of an electronic temperature. DN Mermin, @emph{Phys. Rev.} @strong{137}, A1441 (1965).
@item @strong{cold_smearing}:  N Marzari, D Vanderbilt, A De Vita, and MC Payne, @emph{Phys. Rev. Lett.} @strong{82}, 3296 (1999).
@item @strong{methfessel_paxton}:  M Methfessel and AT Paxton, @emph{Phys. Rev. B} @strong{40}, 3616 (1989).
 In this case, the variable @t{SmearingMPOrder} sets the order of the smearing.
 Occupations may be negative.
@item @strong{spline_smearing}:  Nearly identical to Gaussian smearing.
 JM Holender, MJ Gillan, MC Payne, and AD Simpson, @emph{Phys. Rev. B} @strong{52}, 967 (1995).
@end itemize

@c ----------------------------------
@item @strong{SmearingMPOrder}@*
@vindex @code{SmearingMPOrder}@*
@emph{Section}: States@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Sets the order of the Methfessel-Paxton smearing function.



@c ----------------------------------
@item @strong{SpinComponents}@*
@vindex @code{SpinComponents}@*
@emph{Section}: States@*
@emph{Type}: integer@*
@emph{Default}: unpolarized@*
@* The calculations may be done in three different ways: spin-restricted (TD)DFT (@emph{i.e.}, doubly
 occupied "closed shells"), spin-unrestricted or "spin-polarized" (TD)DFT (@emph{i.e.} we have two
 electronic systems, one with spin up and one with spin down), or making use of two-component
 spinors.


@emph{Options}:
@itemize @minus
@item @strong{unpolarized}:  Spin-restricted calculations.
@item @strong{spin_polarized}:  Spin unrestricted, also known as spin-DFT, SDFT. This mode will double the number of
 wavefunctions necessary for a spin-unpolarized calculation.
@item @strong{spinors}:  The spin-orbitals are two-component spinors. This effectively allows the spin-density to
 be oriented non-collinearly: @emph{i.e.} the magnetization vector is allowed to take different
 directions at different points. This vector is always in 3D regardless of @t{Dimensions}.
@end itemize

@c ----------------------------------
@item @strong{SymmetrizeDensity}@*
@vindex @code{SymmetrizeDensity}@*
@emph{Section}: States@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* When enabled the density is symmetrized. Currently, this can
 only be done for periodic systems.

 It is enabled by default when symmetries are used to reduce the
 k-point grid (KPointsUseSymmetries = yes), otherwise it is
 disabled by default.



@c ----------------------------------
@item @strong{TotalStates}@*
@vindex @code{TotalStates}@*
@emph{Section}: States@*
@emph{Type}: integer@*
@* This variable sets the total number of states that Octopus will
 use. This is normally not necessary since by default Octopus
 sets the number of states to the minimum necessary to hold the
 electrons present in the system. (This default behavior is
 obtained by setting @t{TotalStates} to 0).

 If you want to add some unoccupied states, probably it is more convenient to use the variable
 @t{ExtraStates}.

 Note that this number is unrelated to @t{CalculationMode == unocc}.



@c ----------------------------------
@item @strong{TransformStates}@*
@vindex @code{TransformStates}@*
@emph{Section}: States@*
@emph{Type}: block@*
@emph{Default}: no@*
@* Before starting the @t{td} calculation, the initial states (that are
 read from the @t{restart/gs} directory, which should have been
 generated in a previous ground-state calculation) can be "transformed"
 among themselves. The block @t{TransformStates} gives the transformation matrix
 to be used. The number of rows of the matrix should equal the number
 of the states present in the time-dependent calculation (the independent
 spin and @emph{k}-point subspaces are all transformed equally); the number of
 columns should be equal to the number of states present in the
 @t{restart/gs} directory. This number may be different: for example,
 one could have run previously in @t{unocc} mode in order to obtain unoccupied
 Kohn-Sham states, and therefore @t{restart/gs} will contain more states.
 These states can be used in the transformation.

 Note that the code will not check the orthonormality of the new states!

 Each line provides the coefficients of the new states, in terms of
 the old ones.



@c ----------------------------------
@item @strong{UserDefinedStates}@*
@vindex @code{UserDefinedStates}@*
@emph{Section}: States@*
@emph{Type}: block@*
@* Instead of using the ground state as initial state for
 time-propagations it might be interesting in some cases
 to specify alternate states. Like with user-defined
 potentials, this block allows you to specify formulas for
 the orbitals at @emph{t}=0.

 Example:

 @t{%UserDefinedStates
 @*@ @  1 | 1 | 1 | formula | "exp(-r^2)*exp(-i*0.2*x)" | normalize_yes
 @*%}

 The first column specifies the component of the spinor,
 the second column the number of the state and the third
 contains @emph{k}-point and spin quantum numbers. Column four
 indicates that column five should be interpreted as a formula
 for the corresponding orbital.

 Alternatively, if column four states @t{file} the state will
 be read from the file given in column five.

 @t{%UserDefinedStates
 @*@ @  1 | 1 | 1 | file | "/path/to/file" | normalize_no
 @*%}

 Octopus reads first the ground-state orbitals from
 the @t{restart/gs} directory. Only the states that are
 specified in the above block will be overwritten with
 the given analytic expression for the orbital.

 The sixth (optional) column indicates whether @t{Octopus} should renormalize
 the orbital. The default (no sixth column given) is to renormalize.



@emph{Options}:
@itemize @minus
@item @strong{file}:  Read initial orbital from file.
@item @strong{normalize_no}:  Do not normalize orbitals.
@item @strong{formula}:  Calculate initial orbital by given analytic expression.
@item @strong{normalize_yes}:  Normalize orbitals (default).
@end itemize

@c ----------------------------------
@end itemize
@node System,,,
@section System
@c ----------------------------------

@itemize
@item @strong{ComplexBoundaries}@*
@vindex @code{ComplexBoundaries}@*
@emph{Section}: System@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* (Experimental) If enabled the system will have complex
 boundaries defined by an electrostatic potential. Must be
 used with the SETE poisson solver.



@c ----------------------------------
@item @strong{Dimensions}@*
@vindex @code{Dimensions}@*
@emph{Section}: System@*
@emph{Type}: integer@*
@emph{Default}: 3@*
@* @t{Octopus} can run in 1, 2 or 3 dimensions, depending on the value of this
 variable. Note that not all input variables may be available in all cases.



@c ----------------------------------
@item @strong{PeriodicDimensions}@*
@vindex @code{PeriodicDimensions}@*
@emph{Section}: System@*
@emph{Type}: integer@*
@* Define how many directions are to be considered periodic. It has to be a number
 between zero and @t{Dimensions}.


@emph{Options}:
@itemize @minus
@item @strong{0}:  No direction is periodic (molecule).
@item @strong{1}:  The @emph{x} direction is periodic (wire, polymer).
@item @strong{2}:  The @emph{x} and @emph{y} directions are periodic (slab).
@item @strong{3}:  The @emph{x}, @emph{y}, and @emph{z} directions are periodic (bulk).
@end itemize

@c ----------------------------------
@end itemize
@node Coordinates,,,
@subsection Coordinates
@c ----------------------------------

@itemize
@item @strong{Coordinates}@*
@vindex @code{Coordinates}@*
@emph{Section}: System::Coordinates@*
@emph{Type}: block@*
@* If neither @t{XYZCoordinates} nor @t{PDBCoordinates} was found, @t{Octopus}
 tries to read the coordinates for the atoms from the block @t{Coordinates}. The
 format is quite straightforward:

 @t{%Coordinates
 @*@ @ 'C' |      -0.56415 | 0.0 | 0.0 | no
 @*@ @ 'O' | @ 0.56415 | 0.0 | 0.0 | no
 @*%}

 The first line defines a carbon atom at coordinates (-0.56415, 0.0, 0.0),
 that is @strong{not} allowed to move during dynamical simulations. The second line has
 a similar meaning. This block obviously defines a carbon monoxide molecule, if the
 input units are @t{eV_Angstrom}. The number of coordinates for each species
 must be equal to the dimension of your space (generally 3).
 Note that in this way it is possible to fix some of the atoms (this
 is not possible when specifying the coordinates through a @t{PDBCoordinates} or
 @t{XYZCoordinates} file). The last column is optional, and the default is yes.
 It is always possible to fix @strong{all} atoms using the @t{MoveIons} directive.



@c ----------------------------------
@item @strong{PDBCoordinates}@*
@vindex @code{PDBCoordinates}@*
@emph{Section}: System::Coordinates@*
@emph{Type}: string@*
@* If this variable is present, the program tries to read the atomic coordinates
 from the file specified by its value. The PDB (Protein Data Bank,
 @t{http://www.rcsb.org/pdb/}) format is quite complicated, and it goes
 well beyond the scope of this manual. You can find a comprehensive
 description <a href='http://www.wwpdb.org/docs.html'>here</a>.
 From the plethora of instructions defined in the PDB standard, @t{Octopus}
 only reads two, @t{ATOM} and @t{HETATOM}. From these fields, it reads:
 @itemize

 @item
 columns 13-16: The species; in fact @t{Octopus} only cares about the
 first letter - "CA" and "CB" will both refer to carbon - so elements whose
 chemical symbol has more than one letter cannot be represented in this way.
 So, if you want to run mercury (Hg), please use one of the other two methods
 to input the coordinates: @t{XYZCoordinates} or @t{Coordinates}.
 @item
 columns 18-21: The residue. If residue is @t{QM}, the atom is treated by quantum
 mechanics; otherwise it is simply treated as an external classical point charge.
 Its charge will be given by columns 61-65.
 @item
 columns 31-54: The Cartesian coordinates. The Fortran format is @t{(3f8.3)}.
 @item
 columns 61-65: Classical charge of the atom. The Fortran format is @t{(f6.2)}.
 @end itemize




@c ----------------------------------
@item @strong{ReducedCoordinates}@*
@vindex @code{ReducedCoordinates}@*
@emph{Section}: System::Coordinates@*
@emph{Type}: block@*
@* This block gives the atomic coordinates relative to the real
 space unit cell. The format is the same as the
 @t{Coordinates} block.

 Note that in Octopus the origin of coordinates is in the center
 of the cell, so the coordinates inside the cell are in the
 range [-0.5, 0.5).

 This block cannot be used with the @t{minimum} box shapes.




@c ----------------------------------
@item @strong{XYZCoordinates}@*
@vindex @code{XYZCoordinates}@*
@emph{Section}: System::Coordinates@*
@emph{Type}: string@*
@* If @t{PDBCoordinates} is not present, the program reads the atomic coordinates from
 the XYZ file specified by the variable @t{XYZCoordinates} -- in case this variable
 is present. The XYZ format is very simple: The first line of the file has an integer
 indicating the number of atoms. The second can contain comments that are simply ignored by
 @t{Octopus}. Then there follows one line per atom, containing the chemical species and
 the Cartesian coordinates of the atom.



@c ----------------------------------
@end itemize
@node Species,,,
@subsection Species
@c ----------------------------------

@itemize
@item @strong{IonicInteraction}@*
@vindex @code{IonicInteraction}@*
@emph{Section}: System::Species@*
@emph{Type}: block@*
@* This block defines the type of classical interaction between
 ions. Each line represents the interaction between two types of
 species. The first two columns contain the element symbols, the
 next column is the type of interaction as defined below. The
 next columns are the parameters for the interaction (if
 any). Pairs not specified interact through Coulomb`s law.

 Note: In most cases there is no need to specify this block,
 since Coulomb interaction will be used by default.



@emph{Options}:
@itemize @minus
@item @strong{coulomb}:  Particles interact according to Coulomb`s law. The interaction
 strength is given by the charge of the species. There are no
 parameters.
@item @strong{lennard_jones}:  (Experimental) The Lennard-Jones 12-6 model potential. It has
 the form @math{V(r) = 4\epsilon((\sigma/r)^12 -
 (\sigma/r)^6)}.  The next 2 columns contain the
 @math{\epsilon} and @math{\sigma} (given in the
 corresponding input file units).
@end itemize

@c ----------------------------------
@item @strong{Species}@*
@vindex @code{Species}@*
@emph{Section}: System::Species@*
@emph{Type}: block@*
@* A species is by definition either an "ion" (nucleus + core electrons) described
 through a pseudopotential, or a user-defined model potential.

 Note that some common pseudopotentials are distributed with the code in the
 directory @t{OCTOPUS-HOME/share/PP/}. To use these pseudopotentials you are
 not required to define them explicitly in the @t{Species} block, as defaults
 are provided by the program (you can override these defaults in any case).
 Additional pseudopotentials can be downloaded from the
 <a href='http://www.tddft.org/programs/octopus/wiki/index.php/Pseudopotentials'>
 octopus homepage</a>.

 The format of this block is the following: The first field is
 the name of the species, followed by the atomic mass (in atomic mass
 units). The third field defines the type of species (the valid options
 are detailed below). Each type also needs some parameters given in
 the remaining fields of the row.

 In 3D, @emph{e.g.}

 @t{%Species
 @*@ @ 'O'       | 15.9994 | spec_ps_psf         | 8   | 1 | 1
 @*@ @ 'H'       |  1.0079 | spec_ps_hgh         | 1   | 0 | 0
 @*@ @ 'jlm'     | 23.2    | spec_jelli          | 8   | 5.0
 @*@ @ 'rho'     | 17.0    | spec_charge_density | 6   | "exp(-r/a)"
 @*@ @ 'pnt'     | 32.3    | spec_point          | 2.0
 @*@ @ 'udf'     |  0.0    | spec_user_defined   | 8   | "1/2*r^2"
 @*@ @ 'H_all'   |  1.0079 | spec_full_delta     | 1
 @*@ @ 'H_all'   |  1.0079 | spec_full_gaussian  | 1
 @*%}

 Additionally, all the pseudopotential types (PSF, HGH, FHI, UPF) can take two extra
 fields: default spacing, and default radius (used for minimum simulation box if the
 radius is not specified).


@emph{Options}:
@itemize @minus
@item @strong{spec_ps_psf}:  Troullier Martins pseudopotential in @t{SIESTA} format: the pseudopotential will be
 read from a @t{.psf} file, either in the working
 directory or in the @t{OCTOPUS-HOME/share/octopus/PP/PSF} directory.
 Columns 4, 5, 6 are the atomic number, the maximum
 @emph{l}-component of the pseudopotential to consider in the
 calculation, and the @emph{l}-component to consider as local.
@item @strong{spec_ps_hgh}:  Hartwigsen-Goedecker-Hutter pseudopotentials: column 4 is
 the atomic number and columns 5 and 6 are irrelevant, since they
 are not necessary to define the HGH pseudopotential.
@item @strong{spec_ps_cpi}:  Fritz-Haber pseudopotential: the pseudopotential will be
 read from a @t{.cpi} file, either in the working
 directory or in the @t{OCTOPUS-HOME/share/PP/CPI} directory.
 Columns 4, 5, 6 are the atomic number, the maximum
 @emph{l}-component of the pseudopotential to consider in the
 calculation, and the @emph{l}-component to consider as local.
@item @strong{spec_ps_fhi}:  Fritz-Haber pseudopotential (@t{ABINIT} format): the pseudopotential will be
 read from a @t{.fhi} file, either in the working
 directory or in the @t{OCTOPUS-HOME/share/PP/FHI} directory.
 Columns 4, 5, 6 are the atomic number, the maximum
 @emph{l}-component of the pseudopotential to consider in the
 calculation, and the @emph{l}-component to consider as local.
 Note that you can use the pseudopotentials from @t{ABINIT} homepage.
@item @strong{spec_ps_upf}:  UPF format: the pseudopotential will be
 read from a @t{.UPF} file, either in the working
 directory or in the @t{OCTOPUS-HOME/share/PP/UPF} directory.
 Column 4 is the atomic number. Columns 5 and 6 are
 ignored, as the maximum @emph{l}-component of the pseudopotential to
 consider in the calculation and the @emph{l}-component to consider as
 local are indicated in the pseudopotential file are cannot be changed.
@item @strong{spec_user_defined}:  Species with user-defined potential. In this case, the fourth
 field is the valence charge and the fifth
 field is a string with a mathematical expression that defines the
 potential (you can use any of the @emph{x}, @emph{y}, @emph{z}
 or @emph{r} variables).
@item @strong{spec_full_gaussian}:  A full-potential atom is defined by a Gaussian accumulation of
 positive charge (distorted if curvilinear coordinates are
 used), in the form:

 @math{
 q(r) = z * \beta * exp[ - (\vec{r}-\vec{r0})**2 / (sqrt(2) * \delta * \sigma) ]
 }

 @math{\beta} is chosen in order to maintain proper
 normalization (the integral of @math{q} should sum up to
 @math{z}). @math{\delta} is the grid spacing (the
 grid spacing in the first dimension, to be precise).
 @math{\vec{r0}} is calculated in such a way that the the
 first moment of @math{q(r)/z} is equal to the atomic
 position. For a precise description, see N. A. Modine,
 @emph{Phys. Rev. B} @strong{55}, 10289 (1997).

 Column 4 is the atomic number and column 5 is
 @math{sigma}, the width of the gaussian that should be
 small, but you may run into numerical difficulties if it is too
 small (0.25 by default).
@item @strong{spec_charge_density}:  The potential is created by a distribution of charge. The extra parameters are the
 valence charge of the species, and an expression for the charge distribution.
@item @strong{species_from_file}:  The potential is read from a file, whose name is given in column 5.
@item @strong{spec_full_delta}:  Full atomic potential represented by a delta charge
 distribution. The atom will be displaced to the nearest grid
 point. Column 4 is the atomic number.
@item @strong{spec_point}:  Point charge: the fourth field is the value of the charge.
@item @strong{spec_jelli}:  Jellium sphere: the extra parameters are the charge of the jellium
 sphere (an equal value of valence charge is assumed) and the radius of
 the sphere.
@item @strong{spec_jelli_slab}:  Jellium slab: the extra parameters are the charge of the jellium
 slab (an equal value of valence charge is assumed) and the thickness of
 the slab. The slab extends across the simulation box in the @emph{xy}-plane.
@end itemize

@c ----------------------------------
@item @strong{SpeciesProjectorSphereThreshold}@*
@vindex @code{SpeciesProjectorSphereThreshold}@*
@emph{Section}: System::Species@*
@emph{Type}: float@*
@emph{Default}: 0.001@*
@* The pseudopotentials may be composed of a local part, and a linear combination of nonlocal
 operators. These nonlocal projectors have "projector" form, |@emph{v}><@emph{v}| (or, more generally
 speaking, |@emph{u}><@emph{v}|). These projectors are localized in real space -- that is, the function @emph{v}
 has a finite support around the nucleus. This region where the projectors are localized should
 be small or else the computation time required to operate with them will be very large.

 In practice, this localization is fixed by requiring the definition of the projectors to be
 contained in a sphere of a certain radius. This radius is computed by making sure that the
 absolute value of the projector functions, at points outside the localization sphere, is
 below a certain threshold. This threshold is set by @t{SpeciesProjectorSphereThreshold}.



@c ----------------------------------
@item @strong{SpeciesTimeDependent}@*
@vindex @code{SpeciesTimeDependent}@*
@emph{Section}: System::Species@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* When this variable is set, the potential defined in the block @t{Species} is calculated
 and applied to the Hamiltonian at each time step. You must have at least one @t{spec_user_defined}
 type of species to use this.



@c ----------------------------------
@end itemize
@node Velocities,,,
@subsection Velocities
@c ----------------------------------

@itemize
@item @strong{RandomVelocityTemp}@*
@vindex @code{RandomVelocityTemp}@*
@emph{Section}: System::Velocities@*
@emph{Type}: float@*
@* If this variable is present, @t{Octopus} will assign random
 velocities to the atoms following a Boltzmann distribution with
 temperature given by @t{RandomVelocityTemp} (in degrees Kelvin).



@c ----------------------------------
@item @strong{Velocities}@*
@vindex @code{Velocities}@*
@emph{Section}: System::Velocities@*
@emph{Type}: block@*
@* If @t{XYZVelocities} is not present, octopus will try to fetch the initial
 atomic velocities from this block. If this block is not present, octopus
 will reset the initial velocities to zero. The format of this block can be
 illustrated by this example:

 @t{%Velocities
 @*@ @ 'C'  |      -1.7 | 0.0 | 0.0
 @*@ @ 'O'  | @ 1.7 | 0.0 | 0.0
 @*%}

 It describes one carbon and one oxygen moving at the relative
 velocity of 3.4 velocity units.

 Note: It is important for the velocities to maintain the ordering
 in which the species were defined in the coordinates specifications.



@c ----------------------------------
@item @strong{XYZVelocities}@*
@vindex @code{XYZVelocities}@*
@emph{Section}: System::Velocities@*
@emph{Type}: string@*
@* @t{Octopus} will try to read the starting velocities of the atoms from the XYZ file
 specified by the variable @t{XYZVelocities}.
 Note that you do not need to specify initial velocities if you are not going
 to perform ion dynamics; if you are going to allow the ions to move but the velocities
 are not specified, they are considered to be null.



@c ----------------------------------
@end itemize
@node Time-Dependent,,,
@section Time-Dependent
@c ----------------------------------

@itemize
@item @strong{TDExternalFields}@*
@vindex @code{TDExternalFields}@*
@emph{Section}: Time-Dependent@*
@emph{Type}: block@*
@* The block @t{TDExternalFields} describes the type and shape of time-dependent
 external perturbations that are applied to the system.

 Each line of the block describes an external field; this way you can actually have more
 than one laser (@emph{e.g.} a "pump" and a "probe").

 The syntax of each line is:

 @t{%TDExternalField
 @*@ @  type | ...other descriptors...
 @*%}

 The first element of each line describes which kind of external field is described
 by the line: (i) an electric field (@t{electric_field}); (ii) a magnetic field
 (@t{magnetic_field}); (iii) a vector potential (@t{vector_potential}) -- this option,
 in the current version, is a field constant in space, which permits us to describe
 an electric perturbation in the velocity gauge; (iv) an arbitrary scalar potential
 (@t{scalar_potential}).

 The "other descriptors" depend on which kind of external field has been indicated in
 the first column.

 (A) type = @t{electric field, magnetic field, vector_potential}

 For these cases, the syntax is:

 @t{%TDExternalFields
 @*@ @  type | nx | ny | nz | omega | envelope_function_name
 @*%}

 The three (possibly complex) numbers (@emph{nx}, @emph{ny}, @emph{nz}) mark the polarization
 direction of the field. The float @t{omega} will be the carrier frequency of the
 pulse. The envelope of the field is a time-dependent function whose definition
 must be given in a @t{TDFunctions} block. @t{envelope_function_name} is a string (and therefore
 it must be surrounded by quotation marks) that must match one of the function names
 given in the first column of the @t{TDFunctions} block.

 (B) type = @t{scalar_potential}

 @t{%TDExternalFields
 @*@ @  scalar_potential | "scalar_expression" | freq | envelope_function_name
 @*%}

 The scalar potential is not just a dipole, but any expression given by the string
 "scalar_expression". The temporal shape is determined by the envelope function
 defined by @t{envelope_function_name}.

 A NOTE ON UNITS:

 It is very common to describe the strength of a laser field by its intensity, rather
 than using the electric-field amplitude. In atomic units (or, more precisely, in any
 Gaussian system of units), the relationship between instantaneous electric field
 and intensity is:
 @math{ I(t) = \frac{c}{8\pi} E^2(t) }.

 It is common to read intensities in W/cm^2. The dimensions of intensities are
 [W]/(L^2T), where [W] are the dimensions of energy. The relevant conversion factors
 are:

 @math{ Hartree / (a_0^2 atomic_time) = 6.4364086e+15 W / cm^2 }

 @math{ eV / ( angstrom^2 (hbar/eV) ) = 2.4341348e+12 W / cm^2 }

 If, in atomic units, we set the electric-field amplitude to @math{E_0},
 then the intensity is:

 @math{ I_0 = 3.51 10^16 W/cm^2 (E_0^2) }

 If, working with "Units = ev_angstrom", we set @math{E_0}, then the intensity is:

 @math{ I_0 = 1.327 10^13 (E_0^2) W/cm^2 }



@emph{Options}:
@itemize @minus
@item @strong{electric_field}:  The external field is an electric field, the usual case when we want to describe a
 laser in the length gauge.
@item @strong{magnetic_field}:  The external field is a (homogeneous) time-dependent magnetic field.
@item @strong{vector_potential}:  The external field is a time-dependent homogeneous vector potential, which may describe
 a laser field in the velocity gauge.
@item @strong{scalar_potential}:  The external field is an arbitrary scalar potential, which may describe an
 inhomogeneous electrical field.
@end itemize

@c ----------------------------------
@item @strong{TDFreezeOrbitals}@*
@vindex @code{TDFreezeOrbitals}@*
@emph{Section}: Time-Dependent@*
@emph{Type}: integer@*
@* You have the possibility of "freezing" a number of orbitals during a time-propagation.
 The Hartree and exchange-correlation potential due to these orbitals (which
 will be the lowest-energy ones) will be added during the propagation, but the orbitals
 will not be propagated.

 @strong{WARNING: NOT TESTED YET.}


@emph{Options}:
@itemize @minus
@item @strong{sae}:  Single-active-electron approximation. This option is only valid for time-dependent
 calculations (@t{CalculationMode = td}). Also, the nuclei should not move.
 The idea is that all orbitals except the last one are frozen. The orbitals are to
 be read from a previous ground-state calculation. The active orbital is then treated
 as independent (whether it contains one electron or two) -- although it will
 feel the Hartree and exchange-correlation potentials from the ground-state electronic
 configuration.

 It is almost equivalent to setting @t{TDFreezeOrbitals = N-1}, where @t{N} is the number
 of orbitals, but not completely.
@end itemize

@c ----------------------------------
@item @strong{TDFunctions}@*
@vindex @code{TDFunctions}@*
@emph{Section}: Time-Dependent@*
@emph{Type}: block@*
@* This block specifies the shape of a "time-dependent function", such as the
 envelope needed when using the @t{TDExternalFields} block. Each line in the block
 specifies one function. The first element of each line will be a string
 that defines the name of the function. The second element specifies which type
 of function we are using; in the following we provide an example for each of the
 possible types:

    (1) @t{tdf_cw}

 @t{%TDFunctions
 @*@ @  "function-name" | tdf_cw | amplitude
 @*%}

 The function is just a constant of value @t{amplitude}.

 @math{ f(t) = amplitude

    (2) @t{tdf_gaussian}

 @t{%TDFunctions
 @*@ @  "function-name" | tdf_gaussian | amplitude | tau0 | t0
 @*%}

 The function is a Gaussian:

 <math> f(t) = F_0 exp( - (t-t_0)/(2\tau_0^2) ) }

 @math{F_0} = amplitude.

    (3) @t{tdf_cosinoidal}

 @t{%TDFunctions
 @*@ @  "function-name" | tdf_cosinoidal | amplitude | tau0 | t0
 @*%}

 @math{ f(t) =  F_0 cos( \pi/2 \frac{t-2\tau_0-t_0}{\tau0} )  }

 If @math{ | t - t_0 | > \tau_0 }, then @math{ f(t) = 0 }.

    (4) @t{tdf_trapezoidal}

 @t{%TDFunctions
 @*@ @  "function-name" | tdf_trapezoidal | amplitude | tau0 | t0 | tau1
 @*%}

 The function ramps linearly during @math{tau_1} time units, stays constant for
 @math{tau_0} time units, and the decays to zero linearly again for @math{tau_1}
 time units.

    (5) @t{tdf_from_file}

 @t{%TDFunctions
 @*@ @  "function-name" | tdf_from_file | "filename"
 @*%}

 The temporal shape of the function is contained in a file called @t{filename}. This file
 should contain three columns: first column is time, second and third column are the
 real part and the imaginary part of the temporal function @emph{f}(@emph{t}).

    (A.6) @t{tdf_from_expr}

 @t{%TDFunctions
 @*@ @  "function-name" | tdf_from_expr | "expression"
 @*%}

 The temporal shape of the field is given as an expression (e.g., "cos(2.0*t)". The
 letter @emph{t} means time, obviously. The expression is used to construct the function @emph{f}
 that defines the field:



@emph{Options}:
@itemize @minus
@item @strong{tdf_cw}:  Explained above.
@item @strong{tdf_gaussian}:  Explained above.
@item @strong{tdf_cosinoidal}:  Explained above.
@item @strong{tdf_trapezoidal}:  Explained above.
@item @strong{tdf_from_file}:  Explained above.
@item @strong{tdf_from_expr}:  Explained above.
@end itemize

@c ----------------------------------
@end itemize
@node Absorbing Boundaries,,,
@subsection Absorbing Boundaries
@c ----------------------------------

@itemize
@item @strong{ABHeight}@*
@vindex @code{ABHeight}@*
@emph{Section}: Time-Dependent::Absorbing Boundaries@*
@emph{Type}: float@*
@emph{Default}: -0.2 a.u.@*
@* When @t{AbsorbingBoundaries = sin2}, this is the height of the imaginary potential.



@c ----------------------------------
@item @strong{ABWidth}@*
@vindex @code{ABWidth}@*
@emph{Section}: Time-Dependent::Absorbing Boundaries@*
@emph{Type}: float@*
@emph{Default}: 0.4 a.u.@*
@* Width of the region used to apply the absorbing boundaries.



@c ----------------------------------
@item @strong{AbsorbingBoundaries}@*
@vindex @code{AbsorbingBoundaries}@*
@emph{Section}: Time-Dependent::Absorbing Boundaries@*
@emph{Type}: integer@*
@emph{Default}: not_absorbing@*
@* To improve the quality of the spectra by avoiding the formation of
 standing density waves, one can make the boundaries of the simulation
 box absorbing.


@emph{Options}:
@itemize @minus
@item @strong{not_absorbing}:  No absorbing boundaries.
@item @strong{sin2}:  A @math{\sin^2} imaginary potential is added at the boundaries.
@item @strong{mask}:  A mask is applied to the wavefunctions at the boundaries.
@item @strong{exact}:  NOT WORKING YET!
 An exactly absorbing scheme is used for open boundaries. This feature
 comes from transport calculation and assumes that on @t{OpenBoundariesNLeads}
 sides there is a lead connected. No outgoing density is reflected within the leads,
 but some minor reflection will occur on the corners of the box.
 This is due to the setup of semi-infinite finite width leads connected to the sides.
 Warning: This scheme works only with the special Cranck-Nicholson propagator and has
 quadratic scaling with time. It may be tuned with the parameter @t{OpenBoundariesMaxMemCoeffs}.
@end itemize

@c ----------------------------------
@end itemize
@node Open Boundaries,,,
@subsection Open Boundaries
@c ----------------------------------

@itemize
@item @strong{MemoryMaxIter}@*
@vindex @code{MemoryMaxIter}@*
@emph{Section}: Time-Dependent::Open Boundaries@*
@emph{Type}: integer@*
@emph{Default}: 500@*
@* Sets the maximum iteration number to converge the memory coefficients.



@c ----------------------------------
@item @strong{MemoryTol}@*
@vindex @code{MemoryTol}@*
@emph{Section}: Time-Dependent::Open Boundaries@*
@emph{Type}: float@*
@emph{Default}: 1e-12@*
@* Decides when to consider the memory coefficients converged.



@c ----------------------------------
@end itemize
@node PES,,,
@subsection PES
@c ----------------------------------

@itemize
@item @strong{PESMaskEnlargeLev}@*
@vindex @code{PESMaskEnlargeLev}@*
@emph{Section}: Time-Dependent::PES@*
@emph{Type}: integer@*
@* Mask box enlargement level. Enlarges the mask bounding box by a factor 2**@t{PESMaskEnlargeLev}.
 This will avoid wavefunction wrapping at the boundaries.



@c ----------------------------------
@item @strong{PESMaskFilterCutOff}@*
@vindex @code{PESMaskFilterCutOff}@*
@emph{Section}: Time-Dependent::PES@*
@emph{Type}: float@*
@emph{Default}: -1@*
@* In calculation with @t{PESMaskMode = fullmask_mode} and NFFT, spurious frequencies
 may lead to numerical instability of the algorithm. This option gives the possibility
 to filter out the unwanted components by setting an energy cut-off.
 If @t{PESMaskFilterCutOff = -1} no filter is applied.



@c ----------------------------------
@item @strong{PESMaskIncludePsiA}@*
@vindex @code{PESMaskIncludePsiA}@*
@emph{Section}: Time-Dependent::PES@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Add the contribution of \Psi_A in the mask region to the photo-electron spectrum.
 Literally adds the Fourier components of:
 \Theta(r-R1)*\Psi_A(r)
 with \Theta being the Heaviside step function.
 With this option PES will contain all the contributions starting from the inner
 radius R1. Use this option to improve convergence with respect to the box size
 and total simulation time.
 Note: carefully choose R1 in order to avoid contributions from returning electrons.



@c ----------------------------------
@item @strong{PESMaskMode}@*
@vindex @code{PESMaskMode}@*
@emph{Section}: Time-Dependent::PES@*
@emph{Type}: integer@*
@emph{Default}: mask_mode@*
@* PES calculation mode.


@emph{Options}:
@itemize @minus
@item @strong{mask_mode}:  Mask method.
@item @strong{fullmask_mode}:  Full mask method. This includes a back action of the momentum-space states on the
 interaction region. This enables electrons to come back from the continuum.
@item @strong{passive_mode}:  Passive analysis of the wf. Simply analyze the plane-wave components of the
 wavefunctions on the region @emph{r} > @emph{R1}. This mode employs a step masking function by default.
@item @strong{psf_mode}:  Phase-space filter. Implementation not complete.
@end itemize

@c ----------------------------------
@item @strong{PESMaskNFFTEnlargeLev}@*
@vindex @code{PESMaskNFFTEnlargeLev}@*
@emph{Section}: Time-Dependent::PES@*
@emph{Type}: integer@*
@* Mask box enlargement level. Enlarges the mask box by a factor 2**@t{PESMaskEnlargeLev}
 using NFFT. This way we add two points in each direction at a distance
 L=Lb*2**@t{PESMaskEnlargeLev} where @emph{Lb} is the box size.

 Note: the corresponding Fourier space is restricted by the same factor.



@c ----------------------------------
@item @strong{PESMaskOutputInterpolate}@*
@vindex @code{PESMaskOutputInterpolate}@*
@emph{Section}: Time-Dependent::PES@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Use interpolation to evaluate the quantities in polar coordinates.
 NOTE: In 3D this is practically prohibitive in the present implemetation.
 We suggest to use the postprocessing tool @t{oct-photoelectron_spectrum} in this case.



@c ----------------------------------
@item @strong{PESMaskPlaneWaveProjection}@*
@vindex @code{PESMaskPlaneWaveProjection}@*
@emph{Section}: Time-Dependent::PES@*
@emph{Type}: integer@*
@emph{Default}: fft_map@*
@* With the mask method, wavefunctions in the continuum are treated as plane waves.
 This variable sets how to calculate the plane-wave projection in the buffer
 region. We perform discrete Fourier transforms (DFT) in order to approximate
 a continuous Fourier transform. The major drawback of this approach is the built-in
 periodic boundary condition of DFT. Choosing an appropriate plane-wave projection
 for a given simulation in addition to @t{PESMaskEnlargeLev} and
 @t{PESMaskNFFTEnlargeLev}will help to converge the results.

 NOTE: depending on the value of @t{PESMaskMode} @t{PESMaskPlaneWaveProjection},
 may affect not only performance but also the time evolution of the density.


@emph{Options}:
@itemize @minus
@item @strong{integral}:  Direct integration_map.
@item @strong{fft_out}:  FFT filtered in order to keep only outgoing waves. 1D only.
@item @strong{fft_map}:  FFT transform.
@item @strong{tdpsf_map}:  Time-dependent phase-space filter map.
@item @strong{nfft_map}:  Non-equispaced FFT map.
@item @strong{pfft_map}:  Use PFFT libraries.
@end itemize

@c ----------------------------------
@item @strong{PESMaskPropagator}@*
@vindex @code{PESMaskPropagator}@*
@emph{Section}: Time-Dependent::PES@*
@emph{Type}: integer@*
@emph{Default}: volkov@*
@* Photoelectron waves time-propagation operator in momentum space.


@emph{Options}:
@itemize @minus
@item @strong{free}:  Free plane-wave propagation.
@item @strong{volkov}:  Plane wave evolves with exp(i(p-A(t)/c)^2*dt/2).
@end itemize

@c ----------------------------------
@item @strong{PESMaskShape}@*
@vindex @code{PESMaskShape}@*
@emph{Section}: Time-Dependent::PES@*
@emph{Type}: integer@*
@emph{Default}: m_sin2@*
@* The mask function shape.


@emph{Options}:
@itemize @minus
@item @strong{m_sin2}:  sin2 mask.
@end itemize

@c ----------------------------------
@item @strong{PESMaskSize}@*
@vindex @code{PESMaskSize}@*
@emph{Section}: Time-Dependent::PES@*
@emph{Type}: block@*
@* Set the size of the mask function.
 Here you can set the inner (R1) and outer (R2) radius by setting
 the block as follows:

@t{%PESMaskSize
 @*@ @  R1 | R2
 @*%}




@c ----------------------------------
@item @strong{PESMaskSpectEnergyMax}@*
@vindex @code{PESMaskSpectEnergyMax}@*
@emph{Section}: Time-Dependent::PES@*
@emph{Type}: float@*
@emph{Default}: maxval(mask%Lk)**2/2@*
@* The maximum energy for the PES spectrum.



@c ----------------------------------
@item @strong{PESMaskSpectEnergyStep}@*
@vindex @code{PESMaskSpectEnergyStep}@*
@emph{Section}: Time-Dependent::PES@*
@emph{Type}: float@*
@* The PES spectrum energy step.



@c ----------------------------------
@item @strong{PESMaskStartTime}@*
@vindex @code{PESMaskStartTime}@*
@emph{Section}: Time-Dependent::PES@*
@emph{Type}: float@*
@emph{Default}: -1.0@*
@* The time photoelectrons start to be recorded. In pump-probe simulations this allow to
 get rid of unwanted ionization signal coming from the pump.
 NOTE: this will enforce the mask boundary conditions for all the times.



@c ----------------------------------
@end itemize
@node PhotoElectronSpectrum,,,
@subsection PhotoElectronSpectrum
@c ----------------------------------

@itemize
@item @strong{PhotoElectronSpectrum}@*
@vindex @code{PhotoElectronSpectrum}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: flag@*
@emph{Default}: no@*
@*

@emph{Options}:
@itemize @minus
@item @strong{none}:  The photoelectron spectrum is not calculated. This is the default.
@item @strong{pes_rc}:  Store the wavefunctions at specific points in order to
 calculate the photoelectron spectrum at a point far in the box as proposed in
 A. Pohl, P.-G. Reinhard, and E. Suraud, @emph{Phys. Rev. Lett.} @strong{84}, 5090 (2000).
@item @strong{pes_mask}:  Calculate the photo-electron spectrum using the mask method.
 U. De Giovannini, D. Varsano, M. A. L. Marques, H. Appel, E. K. U. Gross, and A. Rubio,
 @emph{Phys. Rev. A} @strong{85}, 062515 (2012).
@end itemize

@c ----------------------------------
@item @strong{PhotoElectronSpectrumPoints}@*
@vindex @code{PhotoElectronSpectrumPoints}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: block@*
@* List of points at which to calculate the photoelectron spectrum by Suraud method.
 The exact syntax is:

 @t{%PhotoElectronSpectrumPoints
 @*@ @ x1 | y1 | z1
 @*%
 }



@c ----------------------------------
@end itemize
@node Propagation,,,
@subsection Propagation
@c ----------------------------------

@itemize
@item @strong{CPElectronicMass}@*
@vindex @code{CPElectronicMass}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* The fictitious electronic mass used to propagate the electronic
 wavefunctions in the Car-Parrinello formalism.



@c ----------------------------------
@item @strong{CPMethod}@*
@vindex @code{CPMethod}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: verlet@*
@* This variable defines how to integrate the Car-Parrinello
 equations. The default is @t{verlet}.


@emph{Options}:
@itemize @minus
@item @strong{vel_verlet}:  RATTLE/Velocity Verlet integrator.
@item @strong{verlet}:  Standard Verlet.
@end itemize

@c ----------------------------------
@item @strong{MoveIons}@*
@vindex @code{MoveIons}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* This variable controls whether atoms are moved during
 a time propagation run. The default is no.



@c ----------------------------------
@item @strong{RecalculateGSDuringEvolution}@*
@vindex @code{RecalculateGSDuringEvolution}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* In order to calculate some information about the system along the
 evolution (e.g. projection onto the ground-state KS determinant,
 projection of the TDKS spin-orbitals onto the ground-state KS
 spin-orbitals), the ground-state KS orbitals are needed. If the
 ionic potential changes -- that is, the ions move -- one may want
 to recalculate the ground state. You may do this by setting this
 variable.

 The recalculation is not done every time step, but only every
 OutputEvery time steps.



@c ----------------------------------
@item @strong{TDDynamics}@*
@vindex @code{TDDynamics}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: ehrenfest@*
@* Type of dynamics to follow during a time propagation. By default
 it is Ehrenfest TDDFT.


@emph{Options}:
@itemize @minus
@item @strong{ehrenfest}:  Ehrenfest dynamics.
@item @strong{bo}:  Born-Oppenheimer (Experimental).
@item @strong{cp}:  Car-Parrinello molecular dynamics.
@end itemize

@c ----------------------------------
@item @strong{TDEnergyUpdateIter}@*
@vindex @code{TDEnergyUpdateIter}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: 10@*
@* This variable controls how often Octopus updates the total energy
 during a time propagation run. The default is every 10
 iterations. For iterations where the energy is not updated, the
 last calculated value is reported. If you set this variable to 1,
 the energy will be calculated in each step.



@c ----------------------------------
@item @strong{TDExpOrder}@*
@vindex @code{TDExpOrder}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: 4@*
@* For @t{TDExponentialMethod} = @t{standard} or @t{chebyshev},
 the order to which the exponential is expanded. For the Lanczos approximation,
 it is the Lanczos-subspace dimension.



@c ----------------------------------
@item @strong{TDExponentialMethod}@*
@vindex @code{TDExponentialMethod}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: taylor@*
@* Method used to numerically calculate the exponential of the Hamiltonian,
 a core part of the full algorithm used to approximate the evolution
 operator, specified through the variable @t{TDPropagator}.
 In the case of using the Magnus method, described below, the action of the exponential
 of the Magnus operator is also calculated through the algorithm specified
 by this variable.


@emph{Options}:
@itemize @minus
@item @strong{lanczos}:  Allows for larger time-steps.
 However, the larger the time-step, the longer the computational time per time-step.
 In certain cases, if the time-step is too large, the code will emit a warning
 whenever it considers that the evolution may not be properly proceeding --
 the Lanczos process did not converge. The method consists in a Krylov
 subspace approximation of the action of the exponential
 (see M. Hochbruck and C. Lubich, SIAM J. Numer. Anal. @strong{34}, 1911 (1997) for details).
 Two more variables control the performance of the method: the maximum dimension
 of this subspace (controlled by variable @t{TDExpOrder}), and
 the stopping criterion (controlled by variable @t{TDLanczosTol}).
 The smaller the stopping criterion, the more precisely the exponential
 is calculated, but also the larger the dimension of the Arnoldi
 subspace. If the maximum dimension allowed by @t{TDExpOrder} is not
 enough to meet the criterion, the above-mentioned warning is emitted.
@item @strong{taylor}:  This method amounts to a straightforward application of the definition of
 the exponential of an operator, in terms of its Taylor expansion.

 @ifnottex
@verbatim
\exp_@{\rm STD@} (-i\delta t H) = \sum_@{i=0@}^@{k@} @{(-i\delta t)^i\over@{i!@}@} H^i.
@end verbatim
@end ifnottex
@tex
$$
\exp_{\rm STD} (-i\delta t H) = \sum_{i=0}^{k} {(-i\delta t)^i\over{i!}} H^i.
$$
@end tex


 The order @emph{k} is determined by variable @emph{TDExpOder}.
 Some numerical considerations (by Jeff Giansiracusa and George F. Bertsch;
 see http://www.phys.washington.edu/~bertsch/num3.ps)
 suggest the 4th order as especially suitable and stable.
@item @strong{chebyshev}:  In principle, the Chebyshev expansion
 of the exponential represents it more accurately than the canonical or standard expansion.
 As in the latter case, @t{TDExpOrder} determines the order of the expansion.

 There exists a closed analytic form for the coefficients of the exponential in terms
 of Chebyshev polynomials:

 @ifnottex
@verbatim
\exp_@{\rm CHEB@} \left( -i\delta t H \right) = \sum_@{k=0@}^@{\infty@} (2-\delta_@{k0@})(-i)^@{k@}J_k(\delta t) T_k(H),
@end verbatim
@end ifnottex
@tex
$$
\exp_{\rm CHEB} \left( -i\delta t H \right) = \sum_{k=0}^{\infty} (2-\delta_{k0})(-i)^{k}J_k(\delta t) T_k(H),
$$
@end tex


 where @math{J_k} are the Bessel functions of the first kind, and H has to be previously
 scaled to @math{[-1,1]}.
 See H. Tal-Ezer and R. Kosloff, J. Chem. Phys. @strong{81},
 3967 (1984); R. Kosloff, Annu. Rev. Phys. Chem. @strong{45}, 145 (1994);
 C. W. Clenshaw, MTAC @strong{9}, 118 (1955).
@end itemize

@c ----------------------------------
@item @strong{TDIonicTimeScale}@*
@vindex @code{TDIonicTimeScale}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* This variable defines the factor between the timescale of ionic
 and electronic movement. It allows reasonably fast
 Born-Oppenheimer molecular-dynamics simulations based on
 Ehrenfest dynamics. The value of this variable is equivalent to
 the role of @math{\mu} in Car-Parrinello. Increasing it
 linearly accelerates the time step of the ion
 dynamics, but also increases the deviation of the system from the
 Born-Oppenheimer surface. The default is 1, which means that both
 timescales are the same. Note that a value different than 1
 implies that the electrons will not follow physical behaviour.

 According to our tests, values around 10 are reasonable, but it
 will depend on your system, mainly on the width of the gap.

 Important: The electronic time step will be the value of
 @t{TDTimeStep} divided by this variable, so if you have determined an
 optimal electronic time step (that we can call @emph{dte}), it is
 recommended that you define your time step as:

 @t{TDTimeStep} = @emph{dte} * @t{TDIonicTimeScale}

 so you will always use the optimal electronic time step.

 For more details see: @t{http://arxiv.org/abs/0710.3321}




@c ----------------------------------
@item @strong{TDLanczosTol}@*
@vindex @code{TDLanczosTol}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: float@*
@emph{Default}: 1e-5@*
@* An internal tolerance variable for the Lanczos method. The smaller, the more
 precisely the exponential is calculated, and also the bigger the dimension
 of the Krylov subspace needed to perform the algorithm. One should carefully
 make sure that this value is not too big, or else the evolution will be
 wrong.



@c ----------------------------------
@item @strong{TDMaximumIter}@*
@vindex @code{TDMaximumIter}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: 1500@*
@* Number of time-propagation steps that will be performed. By default 1500.

 Tip: If you would like to specify the real time of the
 propagation, rather than the number of steps, just use something
 like:

 @t{TDMaximumIter} = 1000.0 / @t{TDTimeStep}




@c ----------------------------------
@item @strong{TDPropagator}@*
@vindex @code{TDPropagator}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: etrs@*
@* This variable determines which algorithm will be used to approximate
 the evolution operator @math{U(t+\delta t, t)}. That is, given
 @math{\psi(\tau)} and @math{H(\tau)} for @math{tau \le t},
 calculate @math{t+\delta t}. Note that in general the Hamiltonian
 is not known at times in the interior of the interval @math{[t,t+\delta t]}.
 This is due to the self-consistent nature of the time-dependent Kohn-Sham problem:
 the Hamiltonian at a given time @math{\tau} is built from the
 "solution" wavefunctions at that time.

 Some methods, however, do require the knowledge of the Hamiltonian at some
 point of the interval @math{[t,t+\delta t]}. This problem is solved by making
 use of extrapolation: given a number @math{l} of time steps previous to time
 @math{t}, this information is used to build the Hamiltonian at arbitrary times
 within @math{[t,t+\delta t]}. To be fully precise, one should then proceed
 @emph{self-consistently}: the obtained Hamiltonian at time @math{t+\delta t}
 may then be used to interpolate the Hamiltonian, and repeat the evolution
 algorithm with this new information. Whenever iterating the procedure does
 not change the solution wavefunctions, the cycle is stopped. In practice,
 in @t{Octopus} we perform a second-order extrapolation without a
 self-consistency check, except for the first two iterations, where obviously
 the extrapolation is not reliable.

 The proliferation of methods is certainly excessive. The reason for it is that
 the propagation algorithm is currently a topic of active development. We
 hope that in the future the optimal schemes are clearly identified. In the
 mean time, if you do not feel like testing, use the default choices and
 make sure the time step is small enough.


@emph{Options}:
@itemize @minus
@item @strong{qoct_tddft_propagator}:  WARNING: EXPERIMENTAL
@item @strong{qoct_tddft_propagator_2}:  WARNING: EXPERIMENTAL
@item @strong{caetrs}:  (experimental) Corrected Approximated Enforced Time-Reversal
 Symmetry (AETRS), this is the previous propagator but including
 a correction step to the exponential.
@item @strong{etrs}:  The idea is to make use of time-reversal symmetry from the beginning:

 @ifnottex
@verbatim

@end verbatim
@end ifnottex
@tex
$$
    \exp \left(-i\delta t/2 H_{n}\right)\psi_n = exp \left(i\delta t/2 H_{n+1}\right)\psi_{n+1},  
$$
@end tex


 and then invert to obtain:

 @ifnottex
@verbatim

@end verbatim
@end ifnottex
@tex
$$
    \psi_{n+1} = \exp \left(-i\delta t/2 H_{n+1}\right) exp \left(-i\delta t/2 H_{n}\right)\psi_{n}.  
$$
@end tex


 But we need to know @math{H_{n+1}}, which can only be known exactly through the solution
 @math{\psi_{n+1}}. What we do is to estimate it by performing a single exponential:
 @math{\psi^{*}_{n+1}=\exp \left( -i\delta t H_{n} \right) \psi_n}, and then
 @math{H_{n+1} = H[\psi^{*}_{n+1}]}. Thus no extrapolation is performed in this case.
@item @strong{aetrs}:  Approximated Enforced Time-Reversal Symmetry (AETRS).
 A modification of previous method to make it faster.
 It is based on extrapolation of the time-dependent potentials. It is faster
 by about 40%.

 The only difference is the procedure to estimate @math{H_{n+1}}: in this case
 it is extrapolated via a second-order polynomial by making use of the
 Hamiltonian at time @math{t-2\delta t}, @math{t-\delta t} and @math{t}.
@item @strong{exp_mid}:  Exponential Midpoint Rule (EM).
 This is maybe the simplest method, but it is very well grounded theoretically:
 it is unitary (if the exponential is performed correctly) and preserves
 time-reversal symmetry (if the self-consistency problem is dealt with correctly).
 It is defined as:

 @ifnottex
@verbatim

@end verbatim
@end ifnottex
@tex
$$
    U_{\rm EM}(t+\delta t, t) = \exp \left( -i\delta t H_{t+\delta t/2}\right)\,.  
$$
@end tex

@item @strong{crank_nicholson}:  Classical Crank-Nicholson propagator.

 @ifnottex
@verbatim

@end verbatim
@end ifnottex
@tex
$$
   (1 + i\delta t/2 H_{n+1/2}) \psi_{n+1} = (1 - i\delta t/2 H_{n+1/2}) \psi_{n}  
$$
@end tex

@item @strong{crank_nicholson_sparskit}:  Classical Crank-Nicholson propagator. Requires the SPARSKIT library.

 @ifnottex
@verbatim

@end verbatim
@end ifnottex
@tex
$$
   (1 + i\delta t/2 H_{n+1/2}) \psi_{n+1} = (1 - i\delta t/2 H_{n+1/2}) \psi_{n}  
$$
@end tex

@item @strong{magnus}:  Magnus Expansion (M4).
 This is the most sophisticated approach. It is a fourth-order scheme (a feature
 which it shares with the ST scheme; the other schemes are in principle second-order).
 It is tailored for making use of very large time steps, or equivalently,
 dealing with problem with very high-frequency time-dependence.
 It is still in a experimental state; we are not yet sure of when it is
 advantageous.
@item @strong{crank_nicholson_src_mem}:  Crank-Nicholson propagator with source and memory term for transport
 calculations.
@end itemize

@c ----------------------------------
@item @strong{TDStepsWithSelfConsistency}@*
@vindex @code{TDStepsWithSelfConsistency}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: 3@*
@* Since the KS propagator is non-linear, each propagation step
 should be performed self-consistently.  In practice, for most
 purposes this is not necessary, except perhaps in the first
 iterations. This variable holds the number of propagation steps
 for which the propagation is done self-consistently.

 The special value @t{all_steps} forces self-consistency to
 be imposed on all propagation steps. A value of 0 means that
 self-consistency will not be imposed.  The default is 3, which
 means that self-consistency is only enforced during the first three
 steps.


@emph{Options}:
@itemize @minus
@item @strong{all_steps}:  Self-consistency is imposed for all propagation steps.
@end itemize

@c ----------------------------------
@item @strong{TDTimeStep}@*
@vindex @code{TDTimeStep}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: float@*
@* The time-step for the time propagation. For most propagators you
 want to use the largest value that is possible without the
 evolution becoming unstable.

 The default value is the maximum value that we have found
 empirically that is stable for the spacing Octopus is
 using. However, you might need to adjust this value.



@c ----------------------------------
@item @strong{TemperatureFunction}@*
@vindex @code{TemperatureFunction}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: none@*
@* If a thermostat is used, this variable indicates the name
 function of the TDFunctions that will be used to control the
 temperature. The values of the temperature are given in
 degrees Kelvin. The default name for this function is
 "temperature".



@c ----------------------------------
@item @strong{Thermostat}@*
@vindex @code{Thermostat}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: none@*
@* This variable selects the type of thermostat applied to
 control the ionic temperature.


@emph{Options}:
@itemize @minus
@item @strong{none}:  No thermostat is applied. This is the default.
@item @strong{velocity_scaling}:  Velocities are scaled to control the temperature.
@item @strong{nose_hoover}:  Nose-Hoover thermostat.
@end itemize

@c ----------------------------------
@item @strong{ThermostatMass}@*
@vindex @code{ThermostatMass}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* This variable sets the fictitious mass for the Nose-Hoover
 thermostat. The default is 1.0.



@c ----------------------------------
@end itemize
@node Response,,,
@subsection Response
@c ----------------------------------

@itemize
@item @strong{TDDeltaKickTime}@*
@vindex @code{TDDeltaKickTime}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* The delta-perturbation that can be applied by making use of the @t{TDDeltaStrength} variable,
 can be applied at the time given by this variable. Usually, this time is zero, since one wants
 to apply the delta pertubation or "kick" at a system at equilibrium, and no other time-dependent
 external potential is used. However, one may want to apply a kick on top of a laser field,
 for example.



@c ----------------------------------
@item @strong{TDDeltaStrength}@*
@vindex @code{TDDeltaStrength}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: float@*
@* When no laser is applied, a delta (in time) perturbation with
 strength @t{TDDeltaStrength} can be applied. This is used to
 calculate, @emph{e.g.}, the linear optical spectra. If the ions are
 allowed to move, the kick will affect them also.
 The electric field is -(\hbar @emph{k} / @emph{e}) delta(@emph{t}) for a dipole with
 zero wavevector, where @emph{k} = @t{TDDeltaStrength}, which causes
 the wavefunctions instantaneously to acquire a phase exp(@emph{ikx}).
 The unit is inverse length.



@c ----------------------------------
@item @strong{TDDeltaStrengthMode}@*
@vindex @code{TDDeltaStrengthMode}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: integer@*
@emph{Default}: kick_density@*
@* When calculating the density response via real-time propagation,
 one needs to perform an initial kick on the KS system, at
 time zero. Depending on what kind of response property one wants to obtain,
 this kick may be done in several modes.


@emph{Options}:
@itemize @minus
@item @strong{kick_density}:  The total density of the system is perturbed.
@item @strong{kick_spin}:  The individual spin densities are perturbed differently. Note that this mode
 is only possible if the run is done in spin-polarized mode, or with spinors.
@item @strong{kick_spin_and_density}:  A combination of the two above. Note that this mode
 is only possible if the run is done in spin-polarized mode, or with spinors.
@end itemize

@c ----------------------------------
@item @strong{TDDeltaUserDefined}@*
@vindex @code{TDDeltaUserDefined}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: string@*
@* By default, the kick function will be a dipole. This will change if (1) the variable
 TDDeltaUserDefined is present in the inp file, or (2) if the block TDKickFunction
 is present in the inp file. If both are present in the inp file, the TDKickFunction
 block will be ignored. The value of TDDeltaUserDefined should be a string describing
 the function that is going to be used as delta perturbation.



@c ----------------------------------
@item @strong{TDKickFunction}@*
@vindex @code{TDKickFunction}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: block@*
@* If the block @t{TDKickFunction} is present in the input file, and the variable
 "TDDeltaUserDefined" is not present in the input file, the kick function to
 be applied at time zero of the time-propagation will not be a "dipole" function
 (@emph{i.e.} phi => exp(i*k*z) phi), but a general multipole in the form r^l * Y_{lm}(r).

 Each line has two columns of integers: the (@emph{l},@emph{m}) pair that defines the
 multipole. Any number of lines may be given, and the kick will be the sum of those
 multipoles.

 This feature allows calculation of quadrupole, octupole, etc., response functions.



@c ----------------------------------
@item @strong{TDMomentumTransfer}@*
@vindex @code{TDMomentumTransfer}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: block@*
@* Momentum-transfer vector for the calculation of the dynamic structure factor.
 When this variable is set, a non-dipole field is applied, and an output file
 @t{ftchd} is created (it contains the Fourier transform of the charge density
 at each time). The type of the applied external field can be set by
 an optional last number. Possible options are @t{qexp} (default), @t{qcos},
 @t{qsin}, or @t{qcos+qsin}.


@emph{Options}:
@itemize @minus
@item @strong{qexp}:  External field is exp(@emph{iq.r}).
@item @strong{qcos}:  External field is cos(@emph{q.r}).
@item @strong{qsin}:  External field is sin(@emph{q.r}).
@item @strong{qbessel}:  External field is j_l(qr)*Y_lm(r), where q is the length of the momentum-transfer vector.
 In this case the block has to include two extra values (l and m).
@end itemize

@c ----------------------------------
@item @strong{TDPolarization}@*
@vindex @code{TDPolarization}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: block@*
@* The (real) polarization of the delta electric field. Normally
 one needs three perpendicular polarization directions to calculate a
 spectrum (unless symmetry is used).
 The format of the block is:

 @t{%TDPolarization
 @*@ @ pol1x | pol1y | pol1z
 @*@ @ pol2x | pol2y | pol2z
 @*@ @ pol3x | pol3y | pol3z
 @*%}

 @t{Octopus} uses both this block and the variable
 @t{TDPolarizationDirection} to determine the polarization
 vector for the run. For example, if
 @t{TDPolarizationDirection=2} the polarization @t{(pol2x,
 pol2y, pol2z)} would be used.

 The default value for @t{TDPolarization} is the three
 Cartesian unit vectors (1,0,0), (0,1,0), and (0,0,1).

 Note that the directions do not necessarily need to be perpendicular
 when symmetries are used.

 WARNING: If you want to obtain the cross-section tensor, the
 @t{TDPolarization} block must be exactly the same for the run in
 each direction. The direction must be selected by the
 @t{TDPolarizationDirection} variable.




@c ----------------------------------
@item @strong{TDPolarizationDirection}@*
@vindex @code{TDPolarizationDirection}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* When a delta potential is included in a time-dependent run, this
 variable defines in which direction the field will be applied
 by selecting one of the lines of @t{TDPolarization}. In a
 typical run (without using symmetry), the @t{TDPolarization} block
 would contain the three Cartesian unit vectors (the default
 value), and one would make 3 runs varying
 @t{TDPolarization} from 1 to 3.
 If one is using symmetry,  @t{TDPolarization} should run only from 1
 to @t{TDPolarizationEquivAxes}.



@c ----------------------------------
@item @strong{TDPolarizationEquivAxes}@*
@vindex @code{TDPolarizationEquivAxes}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: integer@*
@* Defines how many of the @t{TDPolarization} axes are equivalent. This information is stored in a file and then
 used by @t{oct-propagation_spectrum} to rebuild the full polarizability tensor from just the
 first @t{TDPolarizationEquivAxes} directions. This variable is also used by @t{CalculationMode = vdw}.



@c ----------------------------------
@item @strong{TDPolarizationWprime}@*
@vindex @code{TDPolarizationWprime}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: block@*
@* This block is needed only when
 @t{TDPolarizationEquivAxes} is set to 3.  In such a case,
 the three directions (@emph{pol1}, @emph{pol2}, and @emph{pol3}) defined in
 the @t{TDPolarization} block should be related by symmetry
 operations. If @emph{A} is the symmetry operation that takes you
 from @emph{pol1} to @emph{pol2}, then @t{TDPolarizationWprime}
 should be set to the direction defined by @emph{A}^{-1} @emph{pol3}.
 For more information see MJT Oliveira
 @emph{et al.}, @emph{J. Nanoscience and Nanotechnology} @strong{8},
 3392 (2008).



@c ----------------------------------
@end itemize
@node TD Output,,,
@subsection TD Output
@c ----------------------------------

@itemize
@item @strong{TDDipoleLmax}@*
@vindex @code{TDDipoleLmax}@*
@emph{Section}: Time-Dependent::TD Output@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Maximum multipole of the density output to the file @t{td.general/multipoles}
 during a time-dependent simulation. Must be 0 < @t{TDDipoleLmax < 5}.



@c ----------------------------------
@item @strong{TDExcitedStatesToProject}@*
@vindex @code{TDExcitedStatesToProject}@*
@emph{Section}: Time-Dependent::TD Output@*
@emph{Type}: block@*
@* @strong{[WARNING: This is a *very* experimental feature]} The population of the excited states
 (as defined by <Phi_I|Phi(t)> where |Phi(t)> is the many-body time-dependent state at
 time @emph{t}, and |Phi_I> is the excited state of interest) can be approximated -- it is not clear
 how well -- by substituting for those real many-body states the time-dependent Kohn-Sham
 determinant and some modification of the Kohn-Sham ground-state determinant (@emph{e.g.},
 a simple HOMO-LUMO substitution, or the Casida ansatz for excited states in linear-response
 theory. If you set @t{TDOutput} to contain @t{populations}, you may ask for these approximated
 populations for a number of excited states, which will be described in the files specified
 in this block: each line should be the name of a file that contains one excited state.

 FIXME: description of the format of the files.



@c ----------------------------------
@item @strong{TDOutput}@*
@vindex @code{TDOutput}@*
@emph{Section}: Time-Dependent::TD Output@*
@emph{Type}: flag@*
@emph{Default}: multipoles + geometry + temperature + energy@*
@* Defines what should be output during the time-dependent
 simulation. Many of the options can increase the computational
 cost of the simulation, so only use the ones that you need. In
 most cases the default value is enough, as it is adapted to the
 details of the TD run. The energy and multipoles are always
 calculated. If the ions are allowed to be moved, additionally
 the geometry and the temperature are output. If a laser is
 included it will output by default.


@emph{Options}:
@itemize @minus
@item @strong{gauge_field}:  If set, outputs the vector gauge field corresponding to a spatially uniform (but time-dependent)
 external electrical potential. This is only useful in a time-dependent periodic run.
@item @strong{energy}:  If @t{set}, @t{octopus} outputs the different components of the energy
 to the file @t{td.general/el_energy}.
@item @strong{eigenvalues}:  Write the KS eigenvalues.
@item @strong{geometry}:  If set (and if the atoms are allowed to move), outputs the coordinates, velocities,
 and forces of the atoms to the the file @t{td.general/coordinates}.
@item @strong{multipoles}:  Outputs the multipole moments of the density to the file @t{td.general/multipoles}.
 This is required to, @emph{e.g.}, calculate optical absorption spectra of finite systems. The
 maximum value of @math{l} can be set with the variable @t{TDDipoleLmax}.
@item @strong{temperature}:  If set, the ionic temperature at each step is printed.
@item @strong{td_occup}:  (Experimental) If set, outputs the projections of the
 time-dependent Kohn-Sham wavefunctions onto the static
 (zero-time) wavefunctions to the file
 @t{td.general/projections.XXX}. Only use this option if
 you really need it, as it might be computationally expensive.
@item @strong{angular}:  Outputs the angular momentum of the system, which can be used to calculate circular
 dichroism.
@item @strong{dipole_acceleration}:  When set, outputs the acceleration of the electronic dipole, calculated from the Ehrenfest theorem,
 in the file @t{td.general/acceleration}. This file can then be
 processed by the utility @t{oct-harmonic-spectrum} in order to obtain the harmonic spectrum.
@item @strong{ftchd}:  Write Fourier transform of the electron density to the file @t{ftchds.X},
 where X depends on the kick (e.g. with sin-shaped perturbation X=qsin).
 This is needed for calculating the dynamic structure factor.
 In the case that the kick mode is qbessel, the written quantity is integral over
 density, multiplied by spherical Bessel function times real spherical harmonic.
@item @strong{spin}:  (Experimental) Outputs the expectation value of the spin, which can be used to calculate magnetic
 circular dichroism.
@item @strong{local_mag_moments}:  If set, outputs the local magnetic moments, integrated in sphere centered around each atom.
 The radius of the sphere can be set with @t{LocalMagneticMomentsSphereRadius}.
@item @strong{laser}:  If set, and if there are lasers defined in @t{TDLasers},
 @t{octopus} outputs the laser field to the file @t{td.general/laser}.
@item @strong{dipole_velocity}:  When set, outputs the dipole velocity, calculated from the Ehrenfest theorem,
 in the file @t{td.general/velocity}. This file can then be
 processed by the utility @t{oct-harmonic-spectrum} in order to obtain the harmonic spectrum.
@item @strong{populations}:  (Experimental) Outputs the projection of the time-dependent
 Kohn-Sham Slater determinant onto the ground state (or
 approximations to the excited states) to the file
 @t{td.general/populations}. Note that the calculation of
 populations is expensive in memory and computer time, so it
 should only be used if it is really needed.
@end itemize

@c ----------------------------------
@item @strong{TDProjStateStart}@*
@vindex @code{TDProjStateStart}@*
@emph{Section}: Time-Dependent::TD Output@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Only output projections to states above @t{TDProjStateStart}. Usually one is only interested
 in particle-hole projections around the HOMO, so there is no need to calculate (and store)
 the projections of all TD states onto all static states. This sets a lower limit. The upper limit
 is set by the number of states in the propagation and the number of unoccupied states
 available.



@c ----------------------------------
@end itemize
@node TDPSF,,,
@subsection TDPSF
@c ----------------------------------

@itemize
@item @strong{TDPSFDelta}@*
@vindex @code{TDPSFDelta}@*
@emph{Section}: Time-Dependent::TDPSF@*
@emph{Type}: float@*
@emph{Default}: 0.0001@*
@* Filter error threshold.



@c ----------------------------------
@item @strong{TDPSFKmin}@*
@vindex @code{TDPSFKmin}@*
@emph{Section}: Time-Dependent::TDPSF@*
@emph{Type}: float@*
@emph{Default}: pi/width@*
@* k-space filter width.



@c ----------------------------------
@item @strong{TDPSFSigma}@*
@vindex @code{TDPSFSigma}@*
@emph{Section}: Time-Dependent::TDPSF@*
@emph{Type}: float@*
@emph{Default}: sqrt(2)@*
@* Standard deviation of the phase space filter.



@c ----------------------------------
@end itemize
@node oct-casida_spectrum,,,
@subsection oct-casida_spectrum
@c ----------------------------------

@itemize
@item @strong{CasidaSpectrumBroadening}@*
@vindex @code{CasidaSpectrumBroadening}@*
@emph{Section}: Utilities::oct-casida_spectrum@*
@emph{Type}: float@*
@emph{Default}: 0.005 Ha@*
@* Width of the Lorentzian used to broaden the excitations.



@c ----------------------------------
@item @strong{CasidaSpectrumEnergyStep}@*
@vindex @code{CasidaSpectrumEnergyStep}@*
@emph{Section}: Utilities::oct-casida_spectrum@*
@emph{Type}: float@*
@emph{Default}: 0.001 Ha@*
@* Sampling rate for the spectrum.



@c ----------------------------------
@item @strong{CasidaSpectrumMaxEnergy}@*
@vindex @code{CasidaSpectrumMaxEnergy}@*
@emph{Section}: Utilities::oct-casida_spectrum@*
@emph{Type}: float@*
@emph{Default}: 1.0 Ha@*
@* The broadening is done for energies smaller than @t{CasidaSpectrumMaxEnergy}.



@c ----------------------------------
@item @strong{CasidaSpectrumMinEnergy}@*
@vindex @code{CasidaSpectrumMinEnergy}@*
@emph{Section}: Utilities::oct-casida_spectrum@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* The broadening is done for energies greater than @t{CasidaSpectrumMinEnergy}.



@c ----------------------------------
@end itemize
@node oct-center-geometry,,,
@subsection oct-center-geometry
@c ----------------------------------

@itemize
@item @strong{AxisType}@*
@vindex @code{AxisType}@*
@emph{Section}: Utilities::oct-center-geometry@*
@emph{Type}: integer@*
@emph{Default}: inertia@*
@* After the structure is centered, it is also aligned to a set of orthogonal axes.
 This variable decides which set of axes to use.


@emph{Options}:
@itemize @minus
@item @strong{inertia}:  The axis of inertia.
@item @strong{pseudo_inertia}:  Pseudo-axis of inertia, calculated considering all species to have equal mass.
@item @strong{large_axis}:  The larger axis of the molecule.
@end itemize

@c ----------------------------------
@item @strong{MainAxis}@*
@vindex @code{MainAxis}@*
@emph{Section}: Utilities::oct-center-geometry@*
@emph{Type}: block@*
@* A vector of three reals defining the axis to which the molecule
 should be aligned. If not present, the default value will
 be:
 @t{%MainAxis
 @* 1 | 0 | 1
 @*%}



@c ----------------------------------
@end itemize
@node oct-liquid,,,
@subsection oct-liquid
@c ----------------------------------

@itemize
@item @strong{LiquidDensity}@*
@vindex @code{LiquidDensity}@*
@emph{Section}: Utilities::oct-liquid@*
@emph{Type}: float@*
@* This variable specifies the density of the liquid to be
 generated. It has to be given in units of grammes per cubic
 centimeters @math{gr/cm^3}.



@c ----------------------------------
@item @strong{LiquidMoleculeScale}@*
@vindex @code{LiquidMoleculeScale}@*
@emph{Section}: Utilities::oct-liquid@*
@emph{Type}: float@*
@* This value specifies how much the original molecule will be
 scaled in the liquid. The default is 1.0.



@c ----------------------------------
@item @strong{LiquidNumberOfMolecules}@*
@vindex @code{LiquidNumberOfMolecules}@*
@emph{Section}: Utilities::oct-liquid@*
@emph{Type}: integer@*
@* This variable specifies the number of molecules that will be
 included in the liquid.



@c ----------------------------------
@end itemize
@node oct-propagation_spectrum,,,
@subsection oct-propagation_spectrum
@c ----------------------------------

@itemize
@item @strong{PropagationSpectrumDampFactor}@*
@vindex @code{PropagationSpectrumDampFactor}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: float@*
@emph{Default}: 0.15 au@*
@* If @t{PropagationSpectrumDampMode = exponential}, the damping parameter of the exponential
 is fixed through this variable.



@c ----------------------------------
@item @strong{PropagationSpectrumDampMode}@*
@vindex @code{PropagationSpectrumDampMode}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: integer@*
@emph{Default}: polynomial@*
@* Decides which damping/filtering is to be applied in order to
 calculate spectra by calculating a Fourier transform. The
 default is polynomial damping, except when compressed sensing
 is used. In that case the default is none.


@emph{Options}:
@itemize @minus
@item @strong{none}:  No filtering at all.
@item @strong{exponential}:  Exponential filtering, corresponding to a Lorentzian-shaped spectrum.
@item @strong{polynomial}:  Third-order polynomial damping.
@item @strong{gaussian}:  Gaussian damping.
@end itemize

@c ----------------------------------
@item @strong{PropagationSpectrumEndTime}@*
@vindex @code{PropagationSpectrumEndTime}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: float@*
@emph{Default}: -1.0 au@*
@* Processing is done for the given function in a time-window that ends at the
 value of this variable. If set to a negative value, the maximum value from
 the corresponding multipole file will used.



@c ----------------------------------
@item @strong{PropagationSpectrumEnergyStep}@*
@vindex @code{PropagationSpectrumEnergyStep}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: float@*
@emph{Default}: 0.01 eV@*
@* Sampling rate for the spectrum. If you supply a number equal or smaller than zero, then
 the sampling rate will be (2 * pi / T), where T is the total propagation time.



@c ----------------------------------
@item @strong{PropagationSpectrumMaxEnergy}@*
@vindex @code{PropagationSpectrumMaxEnergy}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: float@*
@emph{Default}: 20 eV@*
@* The Fourier transform is calculated for energies smaller than this value.



@c ----------------------------------
@item @strong{PropagationSpectrumStartTime}@*
@vindex @code{PropagationSpectrumStartTime}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Processing is done for the given function in a time-window that starts at the
 value of this variable.



@c ----------------------------------
@item @strong{PropagationSpectrumTimeStepFactor}@*
@vindex @code{PropagationSpectrumTimeStepFactor}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: integer@*
@emph{Default}: 10@*
@* In the calculation of the vibrational spectrum it not necessary
 to read the velocity at every time step. This variable controls
 the integer factor between the simulation time step and the
 time step used to calculate the vibrational spectrum. The
 default is 10.



@c ----------------------------------
@item @strong{PropagationSpectrumTransform}@*
@vindex @code{PropagationSpectrumTransform}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: integer@*
@emph{Default}: sine@*
@* Decides which transform to perform.


@emph{Options}:
@itemize @minus
@item @strong{exponential}:  Exponential transform @math{\int dt \exp(-wt) f(t)}
@item @strong{sine}:  Sine transform @math{\int dt \sin(wt) f(t)}
@item @strong{cosine}:  Cosine transform @math{\int dt \cos(wt) f(t)}
@end itemize

@c ----------------------------------
@item @strong{PropagationSpectrumType}@*
@vindex @code{PropagationSpectrumType}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: integer@*
@emph{Default}: AbsorptionSpectrum@*
@* Type of spectrum to calculate.


@emph{Options}:
@itemize @minus
@item @strong{AbsorptionSpectrum}:  Photoabsorption spectrum.
@item @strong{EnergyLossSpectrum}:  Dynamic structure factor (also known as energy-loss function or spectrum).
@end itemize

@c ----------------------------------
@item @strong{SpectrumMethod}@*
@vindex @code{SpectrumMethod}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: integer@*
@emph{Default}: fourier@*
@* Decides which method is used to obtain the spectrum. The
 default is the fourier transform.


@emph{Options}:
@itemize @minus
@item @strong{fourier}:  The standard fourier transform.
@item @strong{compressed_sensing}:  (Experimental) Uses the compressed sensing technique.
@end itemize

@c ----------------------------------
@item @strong{SpectrumSignalNoise}@*
@vindex @code{SpectrumSignalNoise}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* For compressed sensing, the signal to process, the
 time-dependent dipole in this case, is assumed to have some
 noise that is given by this quantity. The default value is
 0.0, this value is unitless.



@c ----------------------------------
@end itemize
@node oct-test,,,
@subsection oct-test
@c ----------------------------------

@itemize
@item @strong{TestMode}@*
@vindex @code{TestMode}@*
@emph{Section}: Utilities::oct-test@*
@emph{Type}: integer@*
@emph{Default}: hartree_test@*
@* Decides what kind of test should be performed.


@emph{Options}:
@itemize @minus
@item @strong{hartree_test}:  Tests the various Hartree solvers.
@item @strong{derivatives}:  Tests the implementation of the finite-difference operators, used to calculate derivatives.
@item @strong{orthogonalization}:  Tests the implementation of the orthogonalization routines.
@end itemize

@c ----------------------------------
@item @strong{TestType}@*
@vindex @code{TestType}@*
@emph{Section}: Utilities::oct-test@*
@emph{Type}: integer@*
@emph{Default}: all@*
@* Decides what on what type of values the test should be performed.


@emph{Options}:
@itemize @minus
@item @strong{real}:  Tests derivatives for real functions.
@item @strong{complex}:  Tests derivatives for complex functions.
@item @strong{all}:  Tests derivatives for both real and complex functions.
@end itemize

@c ----------------------------------
@end itemize
@node oct-vibrational_spectrum,,,
@subsection oct-vibrational_spectrum
@c ----------------------------------

@itemize
@item @strong{VibrationalSpectrumTime}@*
@vindex @code{VibrationalSpectrumTime}@*
@emph{Section}: Utilities::oct-vibrational_spectrum@*
@emph{Type}: integer@*
@* This variable controls the maximum time for the calculation of
 the velocity autocorrelation function. The default is the total
 propagation time.



@c ----------------------------------
@end itemize
@node oct-xyz-anim,,,
@subsection oct-xyz-anim
@c ----------------------------------

@itemize
@item @strong{AnimationSampling}@*
@vindex @code{AnimationSampling}@*
@emph{Section}: Utilities::oct-xyz-anim@*
@emph{Type}: integer@*
@emph{Default}: 100@*
@* Sampling rate of the animation. The animation will be constructed using
 the iteration numbers that are multiples of @t{AnimationSampling@t{.



@c ----------------------------------
@end itemize
